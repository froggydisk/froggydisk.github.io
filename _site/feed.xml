<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2025-02-23T11:55:28+07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">froggydisk</title><subtitle>This is for frogs in the world.</subtitle><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><entry><title type="html">[Airflow] docker compose 시 gcc permission denied 에러</title><link href="http://localhost:4000/airflow-docker-error/" rel="alternate" type="text/html" title="[Airflow] docker compose 시 gcc permission denied 에러" /><published>2025-02-23T00:00:00+07:00</published><updated>2025-02-23T00:00:00+07:00</updated><id>http://localhost:4000/airflow-docker-error</id><content type="html" xml:base="http://localhost:4000/airflow-docker-error/"><![CDATA[<h2 id="️-에러">⚠️ 에러</h2>

<p><code class="language-plaintext highlighter-rouge">docker compose</code>로 Airflow를 로컬 테스트하던 중에 <code class="language-plaintext highlighter-rouge">gcc permission denied</code> 에러가 발생했다.</p>

<p>에러가 난 부분을 살펴보니 Dockerfile에서 <code class="language-plaintext highlighter-rouge">RUN pip install -r requirement.txt</code>을 실행할 때 발생하고 있었다.</p>

<p>기존 Airflow 2.9.0 환경에서는 잘 진행되던 것이 2.10.5로 올리면서 갑자기 안되는 경우였으므로 패키지 호환성 문제인가 싶어서 먼저 requirement.txt에서 문제를 일으키는 라이브러리를 찾았다.</p>

<p>trino 관련 패키지가 빌드 시에 전부 gcc 에러를 내뿜고 있었다.</p>

<p>Airflow는 보통 constraint로 패키지들 간 버전이 묶이기 때문에 trino만 다른 버전으로 변경하는 것은 불가능했다.</p>

<p>사실 잘 생각해보면 gcc 에러는 Airflow의 도커 이미지가 권한이 없어서이지 패키지의 문제는 아닐 것이다.</p>

<h2 id="-해결">🔑 해결</h2>

<p>Airflow 공식 문서를 좀 찾아보니 <a href="https://airflow.apache.org/docs/docker-stack/build.html#example-when-you-add-packages-requiring-compilation">도커 빌드에 관한 문서</a>가 있다.</p>

<p><strong>단순히 Airflow의 베이스 이미지에 build-essential이 포함되어 있지 않아서 발생하는 문제였다.</strong></p>

<blockquote>
  <p>The compilation framework of Linux (so called build-essential) is pretty big, and for the production images, size is really important factor to optimize for, so our Production Image does not contain build-essential</p>
</blockquote>

<p>해석해보면 build-essential이 무거워서 최적화를 위해 포함하지 않았다고 쓰여있다.</p>

<p>build-essential을 전부 설치하는 것이 맞는지는 모르겠지만 최적화는 나중으로 생각하고 우선 문서에 나와있는 것처럼 Dockerfile에 다음을 추가해준다.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> apache/airflow</span>
<span class="c"># ==추가 ⬇️==</span>
<span class="k">USER</span><span class="s"> root</span>
<span class="k">RUN </span>apt-get update <span class="se">\
</span>  <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="nt">--no-install-recommends</span> <span class="se">\
</span>         build-essential libopenmpi-dev <span class="se">\
</span>  <span class="o">&amp;&amp;</span> apt-get autoremove <span class="nt">-yqq</span> <span class="nt">--purge</span> <span class="se">\
</span>  <span class="o">&amp;&amp;</span> apt-get clean <span class="se">\
</span>  <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>
<span class="k">USER</span><span class="s"> airflow</span>
...
<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">--no-cache-dir</span> <span class="s2">"apache-airflow==</span><span class="k">${</span><span class="nv">AIRFLOW_VERSION</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-r</span> requirement.txt
</code></pre></div></div>

<p>다시 <code class="language-plaintext highlighter-rouge">docker compose</code>를 해보니 문제없이 빌드된다.</p>

<p>빌드 후 이미지 크기를 보니 100 - 200MB의 용량 증가가 있었다.</p>

<p>기회가 되면 이미지 최적화도 진행해야겠다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Docker, Airflow" /><summary type="html"><![CDATA[⚠️ 에러]]></summary></entry><entry><title type="html">[Git] clone 시 Repository not found 에러</title><link href="http://localhost:4000/git-clone-error/" rel="alternate" type="text/html" title="[Git] clone 시 Repository not found 에러" /><published>2025-02-19T00:00:00+07:00</published><updated>2025-02-19T00:00:00+07:00</updated><id>http://localhost:4000/git-clone-error</id><content type="html" xml:base="http://localhost:4000/git-clone-error/"><![CDATA[<h2 id="️-에러">⚠️ 에러</h2>

<blockquote>
  <p>remote: Repository not found<br />
fatal: repository [저장소 주소] not found</p>
</blockquote>

<p>어느날부터 <code class="language-plaintext highlighter-rouge">git clone</code>을 할 때마다 이런 에러가 뜨기 시작했다.</p>

<p>인증 관련 에러겠거니 하고 그때그때 구글링해서 해결했었는데 이제는 메모를 해놓으려고 한다.</p>

<p>우선 원인 분석을 위해 다음을 테스트 해보았다.</p>

<hr />

<ol>
  <li><code class="language-plaintext highlighter-rouge">git config --global</code> 설정</li>
  <li>키체인에서 github 관련 암호 삭제</li>
  <li><strong>git clone <code class="language-plaintext highlighter-rouge">https://[사용자명]@github.com/~</code></strong> ✨</li>
  <li>git remote [저장소 주소]</li>
  <li><strong>git remote set-url origin <code class="language-plaintext highlighter-rouge">https://[사용자명]@github.com/~</code></strong> ✨</li>
</ol>

<hr />

<p>이 중 효과가 있었던 항목은 볼드체로 표시해 두었다. (사실 중요하진 않음)</p>

<p>처음에는 git config가 문제인 줄 알고 이리저리 수정해 보았지만 사실 config 정보는 <code class="language-plaintext highlighter-rouge">clone</code>이나 <code class="language-plaintext highlighter-rouge">push</code>시에는 사용되지 않는다. 이는 커밋할 때 Git 로그에 기록되는 이름과 이메일을 설정하는 용도이다. 따라서, 사실 그리 중요하지 않은 정보이다.</p>

<p>3번과 5번은 대표적인 성공 사례인데, 잘 보면 둘 다 <code class="language-plaintext highlighter-rouge">github.com</code> 앞에 <strong>사용자명과 @</strong>를 추가해준 것을 볼 수 있다. 매번 저렇게 하는 것은 귀찮을테니 우리는 근본적인 해결책을 찾아야한다.</p>

<p><strong>재미있는 점은 사실 @ 앞에 랜덤한 문자열을 붙여도 그대로 정상 동작이 된다는 것이다!</strong></p>

<p>이를 이해하려면 Git의 자격 증명에 대해서 자세히 알 필요가 있다.</p>

<h2 id="-원인-git-자격-증명-캐시가-남아있음">📍 원인: Git 자격 증명 캐시가 남아있음</h2>

<p>GitHub가 Personal Access Token (PAT) 방식으로 인증 방식을 변경한 것은 다들 알고 있을테고, Git은 <code class="language-plaintext highlighter-rouge">credential.helper</code>를 통해 이러한 자격 증명을 캐싱하는데 (특히 store 방식), 여기서 <strong>만료된 토큰이나 다른 계정의 자격 증명이 캐싱되어 있을 확률이 높다.</strong></p>

<p>더군다나, Git은 <code class="language-plaintext highlighter-rouge">@</code> 앞의 문자열을 단순한 “사용자명”으로 해석하고, 실제 인증은 다른 방식으로 진행하기 때문에 사실상 기존에 캐싱된 정보와 완전히 동일한 <code class="language-plaintext highlighter-rouge">사용자명</code>이 아니기만 하면 이전에 캐싱되어 있던 자격 증명을 쓰지 않고 새로운 증명을 요구하게 된다. (물론 아무것도 입력하지 않은 것도 사용자명으로 간주한다.)</p>

<h2 id="-해결">💡 해결</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"url=https://github.com"</span> | git credential reject
</code></pre></div></div>

<p>이렇게 하면 Git이 저장된 자격 증명을 삭제하고 새로운 토큰을 요구하게 된다.</p>

<p>아래의 명령어로 현재 저장된 자격 증명을 볼 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ~/.git-credentials
</code></pre></div></div>

<h2 id="️-정리">⛱️ 정리</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Repositoy Not Found</code> 에러는 Git에 잘못된 토큰 정보가 캐시되어 있어서 나타난다.</li>
  <li>github.com 앞에 <code class="language-plaintext highlighter-rouge">사용자명 + @</code>를 붙이는 것은 일시적인 해결책이 될 수 있지만 근본적인 해결책은 아니다.</li>
  <li>사용자명은 인증 시에 중요하게 사용되지 않는다. 새로운 캐시를 만들 뿐…</li>
</ul>

<p>캐시를 삭제해준 뒤에 다시 <code class="language-plaintext highlighter-rouge">git clone</code>을 사용하게 되면 새로운 토큰을 요구할 것이고 정상적으로 인증된다면 해당 정보가 새롭게 캐시되어 이후 git 명령어 사용시에 자동으로 활용된다는 것이다. <strong>사용자가 지정되지 않은 바닐라 github.com 주소 관련 캐시에 유효한 토큰이 저장되어 있는지가 중요하다.</strong></p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Git, config" /><summary type="html"><![CDATA[⚠️ 에러]]></summary></entry><entry><title type="html">[ML/DL] RTX 4090 2-way 딥러닝 서버 견적</title><link href="http://localhost:4000/server-build/" rel="alternate" type="text/html" title="[ML/DL] RTX 4090 2-way 딥러닝 서버 견적" /><published>2025-02-18T00:00:00+07:00</published><updated>2025-02-18T00:00:00+07:00</updated><id>http://localhost:4000/server-build</id><content type="html" xml:base="http://localhost:4000/server-build/"><![CDATA[<p>간단한 LLM 모델을 돌려보기 위한 딥러닝 서버를 구축해야할 일이 있었다.</p>

<p>우선 예산이 한정되어 있었기에 비용 절감을 위해 최대한 커스텀을 피하고자 하였다. 다만 RTX 4090 한 대 만으로는 VRAM이 부족하기에 두 장까지 장착하는 것을 고려하여 견적을 짰다.</p>

<p>2024년 막바지에 들어서서는 50번대 엔비디아 GPU의 등장으로 인해 시장에서 4090 신품을 구하기가 하늘에 별따기 수준이었다. 더군다나 2-way로 장착해야 하는 상황에서는 최대한 얇은 모델을 구해야했기에 상황은 더욱 어려웠다.</p>

<h2 id="-견적">🧾 견적</h2>

<p>우선 각 부품별로 고려했던 제품 리스트를 나열하자면 다음과 같다.
볼드체로 표시된 항목은 최종적으로 선택한 것들이다.</p>

<h3 id="cpu">CPU</h3>

<ul>
  <li><strong>AMD 라이젠9-5세대 7950X3D (라파엘) (멀티팩(정품))</strong> ✨</li>
  <li>AMD 라이젠9-6세대 9950X (그래니트 릿지) (정품)</li>
  <li>AMD 라이젠9-5세대 7950X (라파엘) (멀티팩(정품))</li>
</ul>

<h3 id="메인보드">메인보드</h3>

<ul>
  <li><strong>ASUS ProArt X870E-CREATOR WIFI 대원씨티에스</strong> ✨</li>
  <li>ASUS TUF Gaming X670E-PLUS WIFI 대원씨티에스</li>
  <li>ASRock X670E Taichi 대원씨티에스</li>
</ul>

<h3 id="메모리">메모리</h3>

<ul>
  <li><strong>G.SKILL DDR5-5200 CL40 FLARE X5 J 패키지 (96GB(48Gx2))</strong> ✨</li>
  <li>ESSENCORE KLEVV DDR5-5600 CL46 파인인포 (32GB)</li>
  <li>ADATA DDR5-5600 CL46-45-45 (32GB)</li>
  <li>PATRIOT DDR5-5600 CL46 EVO (32GB)</li>
  <li>마이크론 Crucial DDR5-5600 CL46 PRO 패키지 대원씨티에스 (96GB(48Gx2))</li>
</ul>

<h3 id="그래픽카드-gpu">그래픽카드 (GPU)</h3>

<ul>
  <li><strong>RTX 4090 블로워 팬</strong> ✨</li>
  <li>GIGABYTE 지포스 RTX 4090 Gaming OC D6X 24GB 피씨디렉트</li>
  <li>MSI 지포스 RTX 4090 게이밍 X 슬림 D6X 24GB 트라이프로져3</li>
  <li>GIGABYTE 지포스 RTX 4090 WINDFORCE V2 D6X 24GB 피씨디렉트</li>
</ul>

<h3 id="ssd">SSD</h3>

<ul>
  <li><strong>마이크론 Crucial T500 M.2 NVMe 아스크텍 (2TB)</strong> ✨</li>
  <li>마이크론 Crucial T705 M.2 NVMe 아스크텍 (1TB)</li>
  <li>Western Digital WD BLACK SN850X M.2 NVMe (2TB)</li>
</ul>

<h3 id="케이스">케이스</h3>

<ul>
  <li><strong>리안리 PC-011D EVO RGB Black (미들타워)</strong> ✨</li>
  <li>마이크로닉스 ML-420 BTF 화이트 (빅타워)</li>
  <li>Antec PERFORMANCE 1 MESH SILENT (빅타워)</li>
  <li>Fractal Design Meshify 2 XL Dark 강화유리</li>
</ul>

<h3 id="파워서플라이">파워서플라이</h3>

<ul>
  <li><strong>마이크로닉스 ASTRO II GD 1650W 80PLUS GOLD 풀모듈러 ATX 3.0 (PCIE5)</strong> ✨</li>
  <li>HYDRO PTM PRO 1650W Platinum ATX3.0 (12V-2x6)</li>
  <li>(SuperFlower) SF-2000F14HP LEADEX PLATINUM /파워</li>
  <li>SilverStone HELA 2050R Platinum 마이크로닉스</li>
</ul>

<h3 id="cpu-쿨러">CPU 쿨러</h3>

<ul>
  <li><strong>NZXT KRAKEN Elite 360 RGB (black)</strong> ✨</li>
  <li>발키리 C420 ARGB (BLACK)</li>
  <li>ARCTIC Liquid Freezer III 420 서린</li>
  <li>3RSYS Socoool RC1900N 솔더링 (BLACK)</li>
  <li>DARKFLASH NEBULA DN-360 ARGB (블랙)</li>
  <li>PentaWave S06D LE ARGB</li>
  <li>Thermalright Peerless Assassin 120 SE 서린</li>
</ul>

<h3 id="시스템-쿨러">시스템 쿨러</h3>

<ul>
  <li><strong>ARCTIC P12 PWM PST ARGB Value Pack</strong> ✨</li>
</ul>

<p>하드웨어에 대해서 잘 아는 편이 아니기에 커뮤니티 글을 많이 찾아보면서 선택하였고 호환성 문제가 일어나지 않도록 최대한 신경을 썼다.</p>

<h2 id="-선택-이유">🔖 선택 이유</h2>

<p>각 부품에 대해서 선택 이유를 간단히 이야기하자면 아래와 같다.</p>

<ul>
  <li>CPU (AMD 라이젠 9-5세대 7950X3D 라파엘)<br />
기존에 쓰던 CPU가 있어서 재활용하였다. 사실 3D 모델이라 게임에 좀 더 적합하긴 하다.</li>
  <li>메인보드 (ASUS ProArt X870E-CREATOR WIFI STCOM)<br />
보통 ASRock도 많이 선택하는 것 같은데 개인적 경험에서는 ASUS가 더 튼튼한 느낌이다.</li>
  <li>메모리 (G.SKILL DDR5-5200 CL40 FLARE X5 J 패키지 48GB x 2)<br />
32, 64, 128 단위가 24, 48, 96 보다는 안정성이 좋다는 말이 있어서 32GB를 4개 꽂을까 하다가 풀뱅크보다는 아무래도 48GB 두 개가 나을 것 같아 선택하였다. 하지만 LLM을 고려한다면 결국 48GB로 풀뱅크를 해야할 수도 있지 않을까 생각한다.</li>
  <li>그래픽카드 (RTX 4090 블로워 팬)<br />
윈드포스 모델이 제일 얇아서 그걸로 찾고 있었지만 40번대 단종 문제로 아무것도 구할 수가 없어서 용산에 쭉 연락을 돌리다가 블로워 모델 재고만 있어서 울며 겨자 먹기로 주문하였다. 블로워 모델은 게임용이 아니기에 RPM이 일반 모델보다 높게 올라가므로(대략 5,200rpm) 온도 관리는 수월하지만 엄청난 소음 문제가 존재한다. 하지만 실제로 성능 100%를 사용하는 게임 및 AI 훈련을 돌렸보았지만 생각보다는 큰 소리가 아니어서 한시름 놓았다. 물론 가정용이라면 극구 반대한다.</li>
  <li>SSD (마이크론 Crucial T500 M.2 NVMe 대원씨티에스 2TB)<br />
이건 취향 문제라 별 생각없이 구매하였다.</li>
  <li>케이스 (리안리 PC-O11D EVO RGB Black 미들타워)<br />
온도 관리가 제일 중요한 이슈여서 빅타워로 해야하나 했지만 리안리 미들타워도 꽤나 커서 이걸로 사길 잘했다고 생각한다. 미들 타워에서는 꽤 유명하고 어항 감성이 있어서 좋다.</li>
  <li>파워서플라이 (마이크로닉스 ASTRO II GD 1650W 80PLUS GOLD 풀모듈러 ATX 3.0)<br />
보통 파워는 1650W 또는 2000W로 갈리는데, 4090이 워낙 전력 적게 먹기로 소문난 놈이라 아마 괜찮겠지하고 싼 걸로 골랐다.</li>
  <li>CPU 쿨러 (NZXT KRAKEN Elite 360 RGB black)<br />
돈을 아끼려면 아낄 수 있었지만 화면 나오는 쿨러가 가지고 싶어서 구매하였다. 물론 크라켄 수냉 쿨러는 유명하므로 성능에 대한 의심은 없다.</li>
  <li>시스템 쿨러 (ARCTIC P12 PWM PST ARGB Value Pack 서린 black)<br />
GPU가 2장이라 온도 관리가 중요하므로 케이스 아래쪽 흡기에 쓸 생각으로 구매하였다.</li>
</ul>

<h2 id="-후기">🐌 후기</h2>

<p>기존에 있던 CPU를 써야했고 GPU는 따로 구매하였기에, 조립 서비스를 이용하였으나 반절은 다시 직접 작업해야 하였다. 그렇지만 이용할 수 있으면 무조건 조립 해달라고 하는 것이 편하다.</p>

<p>리스트에는 없지만 GPU 한 장은 수직 장착을 하기에 라이저 킷과 브라켓도 구매해 주었다 (<a href="https://lian-li.com/product/o11d-evo-rgb/">참고</a>). 시간적 여유만 된다면 알리에서 싸게 구할 수 있다. 리안리 PC-O11D EVO RGB(미들타워)의 경우 보통 업라이트 킷만 사고 브라켓을 구매하지 않아서 조립할 때 헤매는 듯 싶다 (<a href="https://lian-li.com/product/o11d-evo-upright-gpu-bracket-for-40-series-gpu/">브라켓</a>).</p>

<p>2025년 초 기준, CPU와 GPU를 제외한 비용은 250만원 정도선이고, 총 비용은 1,000만원 조금 넘는 정도라고 볼 수 있다. 만약, 커스텀이나 완성품을 사게 된다면 비용은 훨씬 올라갈 것이므로 되도록이면 드래곤볼 하는 것을 추천한다.</p>

<p>이후 조립기나 사용기도 간간이 올릴 생각이다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Deep Learning, Server, GPU" /><summary type="html"><![CDATA[간단한 LLM 모델을 돌려보기 위한 딥러닝 서버를 구축해야할 일이 있었다.]]></summary></entry><entry><title type="html">[쿠버네티스] Harbor Core가 실행되지 않을 때</title><link href="http://localhost:4000/harbor-core-error/" rel="alternate" type="text/html" title="[쿠버네티스] Harbor Core가 실행되지 않을 때" /><published>2025-01-21T00:00:00+07:00</published><updated>2025-01-21T00:00:00+07:00</updated><id>http://localhost:4000/harbor-core-error</id><content type="html" xml:base="http://localhost:4000/harbor-core-error/"><![CDATA[<p>오랜만에 Helm을 이용해서 Harbor를 새로 띄우는 작업을 했다.</p>

<p>웬걸, <code class="language-plaintext highlighter-rouge">harbor-core</code>와 <code class="language-plaintext highlighter-rouge">harbor-registry</code>가 <code class="language-plaintext highlighter-rouge">Running</code>으로 바뀌질 않는다.</p>

<p><code class="language-plaintext highlighter-rouge">kubectl logs</code>로 로그를 보니 <code class="language-plaintext highlighter-rouge">harbor-core</code>의 문제였다.</p>

<p>좀 더 보니 <code class="language-plaintext highlighter-rouge">Redis</code>에 연결하지 못하는 문제가 있는 듯했다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>failed to ping redis://my-harbor-redis:6379/0?idle_timeout_seconds=30...
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">harbor-redis</code> 파드 안으로 들어가서 <code class="language-plaintext highlighter-rouge">Redis</code> 접속이 가능한지 확인하고 <code class="language-plaintext highlighter-rouge">ping</code>도 보내보았는데 별다른 문제가 없었다.</p>

<p>버전 문제인가 하여 헬름 차트를 바꿔가며 버전별로 실행을 했지만 <code class="language-plaintext highlighter-rouge">helm install</code>을 할 때마다 계속해서 같은 문제가 발생했다.</p>

<p>그러다가 <code class="language-plaintext highlighter-rouge">goharbor</code>의 깃헙 레포에서 이슈 하나를 발견했는데 다행히도 나와 같은 증상을 겪은 사람이 있었다. (<a href="https://github.com/goharbor/harbor-helm/issues/1216]">참고</a>)</p>

<p>요는 <code class="language-plaintext highlighter-rouge">쿠버네티스 DNS</code>에 문제가 있는지 확인하라는 내용이었다.</p>

<p><code class="language-plaintext highlighter-rouge">kube-system</code> 네임스페이스에 있는 <code class="language-plaintext highlighter-rouge">coredns</code> 파드를 확인하고 모두 지워 재시작해주니 <code class="language-plaintext highlighter-rouge">harbor-core</code>가 <code class="language-plaintext highlighter-rouge">redis</code>를 정상적으로 찾기 시작했다.</p>

<p><code class="language-plaintext highlighter-rouge">VPN</code>을 설정하다가 <code class="language-plaintext highlighter-rouge">10.0.0.1/24</code>번대 <code class="language-plaintext highlighter-rouge">IP</code>를 건드릴 일이 있었는데 그 때 <code class="language-plaintext highlighter-rouge">쿠버네티스 DNS</code> 설정과 충돌한 것이 아닐까 추측해본다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Kubernetes, Harbor" /><summary type="html"><![CDATA[오랜만에 Helm을 이용해서 Harbor를 새로 띄우는 작업을 했다.]]></summary></entry><entry><title type="html">[React Native] 갑자기 Hot Reload가 안될 때 대처법</title><link href="http://localhost:4000/hot-reload/" rel="alternate" type="text/html" title="[React Native] 갑자기 Hot Reload가 안될 때 대처법" /><published>2024-07-08T00:00:00+07:00</published><updated>2024-07-08T00:00:00+07:00</updated><id>http://localhost:4000/hot-reload</id><content type="html" xml:base="http://localhost:4000/hot-reload/"><![CDATA[<p>VSCode에서 앱 작업을 하며 코드 저장을 할 때마다 변경 사항이 자동으로 시뮬레이터나 디바이스에 반영이 되는 편리함에 취해있던 어느날.</p>

<p>갑자기 <code class="language-plaintext highlighter-rouge">Hot Reload</code>가 먹통이 되었다.</p>

<p>따로 설정을 해준 적도 없었기에 어떻게 살려낼 수 있을지 막막했다.</p>

<p>여러 원인을 감각적으로는 알고 있었는데 정리해놓은 적이 없어서 후회가 몰려왔다.</p>

<p>그래서 이번 기회에 정리하기로 마음먹었다.</p>

<p>이미 <a href="https://github.com/facebook/react-native/issues/33102">React Native 깃 페이지</a>에서 이슈로 다뤄진 내용이라 레퍼런스 찾는 것은 어렵지 않았다.</p>

<p>정리하자면 다음과 같다.</p>

<h2 id="1">1</h2>

<p>iOS 기준으로 <code class="language-plaintext highlighter-rouge">cmd + D</code>를 누르거나 디바이스를 좌우로 흔들어 개발자 창을 연다. 이후 <code class="language-plaintext highlighter-rouge">enable fast refresh</code>를 시킨다.<br />
➡ 필자는 해당 버튼을 찾을 수가 없어서 실패하였다.</p>

<h2 id="2">2</h2>

<p>디바이스와 컴퓨터가 완전히 동일한 와이파이 네트워크상에 존재하는지 확인한다. (이름이 같아도 2.4G/5G는 다른 네트워크다!) 물론 시뮬레이터로 작업할 때는 관련이 없다.</p>

<h2 id="3">3</h2>

<p>프로젝트의 루트 경로로 가서 다음과 같은 명령어를 입력한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> <span class="nt">-rf</span> .git/index.lock
</code></pre></div></div>

<p>의외로 이 방법으로 해결한 사람들이 많은 듯하다. 필자도 <code class="language-plaintext highlighter-rouge">index.lock</code> 파일을 지워주었더니 거짓말처럼 문제가 해결되었다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Hot Reload, Fast Refresh" /><summary type="html"><![CDATA[VSCode에서 앱 작업을 하며 코드 저장을 할 때마다 변경 사항이 자동으로 시뮬레이터나 디바이스에 반영이 되는 편리함에 취해있던 어느날.]]></summary></entry><entry><title type="html">[RN/AI] Pytorch로 AI 모델을 학습시켜 모바일 앱에 적용하기</title><link href="http://localhost:4000/ai-on-app/" rel="alternate" type="text/html" title="[RN/AI] Pytorch로 AI 모델을 학습시켜 모바일 앱에 적용하기" /><published>2024-06-30T00:00:00+07:00</published><updated>2024-06-30T00:00:00+07:00</updated><id>http://localhost:4000/ai-on-app</id><content type="html" xml:base="http://localhost:4000/ai-on-app/"><![CDATA[<p>앱을 만들다보면 자연스레 AI 기술에 관심을 가지게 된다.</p>

<p>“요즘 chatGPT가 그렇게 핫하다는데 나도 AI 좀 접목시켜 볼까…?” 라는 상상을 하게 된다</p>

<p>그렇다면 어떻게 해야할까? 하나하나 차근차근 파헤쳐보자.</p>

<div align="center">
  <img src="/assets/img/dog-nose.gif" alt="video" width="50%" />
  <figcaption>AI를 활용한 강아지 코 인식</figcaption>
</div>

<p>위 영상은 카메라에 비친 물체 중에서 강아지의 코를 인식하는 영상이다. 이는 Object Detection이라는 기술을 활용하고 있다.</p>

<p>Object Detection에 대한 설명은 다음과 같다.</p>

<blockquote>
  <p>이미지나 비디오에서 사람, 자동차, 동물, 가방 등과 같은 특정 객체를 식별하고, 이 객체들의 위치를 정확히 찾아내는 기술. 대표적인 모델로는 YOLO, SSD, Faster R-CNN 등이 있고 자율 주행, 보안 및 감시, 영상 분석 등에 활용된다.</p>
</blockquote>

<p>※ 혹시 chatGPT와 같은 NLP(자연언어처리)를 생각하고 왔는데 실망하신 분이 있을지도 모르겠다. 하지만 딥러닝 기술은 CV가 되었든 NLP가 되었든 기본적인 원리에서는 큰 차이가 없다. 과거에는 방법론적인 차이가 분명이 존재했지만 현재 두 분야는 그러한 경계선조차 점점 허물어지고 있다. 따라서 어느쪽을 익혀두면 나머지를 응용하는 것은 꽤나 쉽다. 고로 둘 다 해보는 것을 추천한다.</p>

<p>이번 글에서는 Object Detection을 활용한 강아지 코 인식 모델을 React Native 앱에 적용해볼 것이다.</p>

<h2 id="-프로세스">🍀 프로세스</h2>

<p>전체적인 흐름은 다음과 같다.</p>

<p><img src="/assets/img/ai-process.png" alt="이미지" /></p>

<h3 id="1-데이터-라벨링">1. 데이터 라벨링</h3>

<p>AI 모델을 훈련시키기 위해서는 그에 적합한 데이터가 필요하다.</p>

<p>오픈소스 데이터를 활용하는 것이 가장 좋지만, 원하는 데이터가 없다면 직접 만들 수밖에 없다.</p>

<p>여기서는 <code class="language-plaintext highlighter-rouge">labelImg</code>라는 라벨러를 사용하여 데이터를 직접 만들어볼 것이다.</p>

<p>(이 과정이 정 귀찮다면 파인튜닝된 모델을 깃허브, 허깅페이스 같은 곳에서 받아와서 사용해도 좋다.)</p>

<h3 id="2-데이터-전처리">2. 데이터 전처리</h3>

<p>모델을 학습시키는 데이터의 형식에는 여러가지가 있지만 우리가 만들 모델은 csv를 필요로 하기에 xml 형태의 데이터를 csv로 변환할 것이다.</p>

<p>실전에서는 원하는 모델의 형식에 맞게 데이터셋을 변형해보자.</p>

<h3 id="3-모델-훈련">3. 모델 훈련</h3>

<p>만들어 놓은 데이터셋으로 모델을 학습시켜본다.</p>

<p>GPU가 있으면 더 빠르고 좋지만, CPU로도 나름 괜찮은 모델을 학습할 수 있다.</p>

<p>우리는 도커를 통해 딥러닝용 가상환경 위에서 학습을 진행할 것이다.</p>

<h3 id="4-모델-테스트">4. 모델 테스트</h3>

<p>의도한대로 잘 학습이 진행되었는지, 정확도는 얼마인지, 실제로 잘 작동하는지 확인한다.</p>

<p>더불어 라이브 테스트도 진행해보자.</p>

<h3 id="5-모델-변형">5. 모델 변형</h3>

<p>우리가 훈련시킨 모델을 모바일 앱에서 사용하기 위해서는 특정 형식이 필요하다.</p>

<p>모델 파일 형식이 <code class="language-plaintext highlighter-rouge">.pth</code>로 되어있을텐데, 이를 <code class="language-plaintext highlighter-rouge">.ptl</code>파일로 변경해주어야 한다.</p>

<p>이 과정에서 <code class="language-plaintext highlighter-rouge">torch.jit</code>을 통한 모델 튜닝에 관한 이야기를 할 것이다.</p>

<h3 id="6-모델-적용">6. 모델 적용</h3>

<p>해당 모델을 실제로 <code class="language-plaintext highlighter-rouge">React Native</code> 프로젝트에도 적용해보자.</p>

<p>결과물을 보고 모델 최적화에 대해서도 고민해보자.</p>

<p><br /></p>

<hr />

<h2 id="️-데이터-라벨링-data-labeling">🏷️ 데이터 라벨링 (Data Labeling)</h2>

<p>모델 학습에 필요한 데이터를 만들기 위해서는 원본(raw) 데이터와 라벨링 툴이 필요하다.
(*Object Detection에 필요한 데이터는 원본 이미지와 바운딩 박스에 관한 좌표 정보이다.)</p>

<p>먼저 원본 데이터부터 준비하자.</p>

<p>원본 데이터는 <a href="http://vision.stanford.edu/aditya86/ImageNetDogs/">Stanford Dogs Dataset</a>을 사용할 것이다. 120종의 강아지 사진 총 20,580장이 모여있는 데이터셋이다.</p>

<p>모든 이미지를 사용할 필요는 없고, 원하는만큼 이미지를 특정 폴더로 옮겨준다. (모델 성능이 잘 안나올 경우 나중에 더 많은 데이터를 가져오면 되므로 일단은 조금만 옮겨보자. 물론 층화 샘플링(Stratified Sampling)을 해주면 가장 좋다.)</p>

<p>해당 폴더는 이제 새로운 데이터셋 폴더로 사용될 것이다.</p>

<p>기본 데이터가 준비되었다면 이제 <a href="https://github.com/HumanSignal/labelImg">labelImg</a>라는 툴을 소개하고자 한다. 간단히 설명하자면 다음과 같다.</p>

<blockquote>
  <p>Object Detection 모델 학습에 필요한 주석(Annotation) 처리된 이미지를 생성할 수 있게 도와주는 도구이다.</p>
</blockquote>

<p>깃허브 페이지에 들어가보면 설치 및 사용 방법에 대해 상세히 설명하고 있다.</p>

<p>단, 필자는 <code class="language-plaintext highlighter-rouge">M1 Pro chip MacBook Pro 14</code>를 사용하고 있는데 설치 가이드에 부족한 내용이 있어 관련 내용을 추가한다.</p>

<p><strong>⚠️ pyrcc5: No such file or directory</strong> 혹 이러한 에러를 만난다면 아래 코드대로 설치한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>qt qt@5
brew <span class="nb">install </span>libxml2
brew <span class="nb">install </span>pyqt@5
pip3 <span class="nb">install </span>pyqt5 lxml
git clone https://github.com/HumanSignal/labelImg.git
<span class="nb">cd </span>labelImg
make qt5py3
python3 labelImg.py
</code></pre></div></div>

<p>실행 화면은 아래와 같다.</p>

<p><img src="/assets/img/labelImg.png" alt="labelImg" /></p>

<p><code class="language-plaintext highlighter-rouge">labelImg/data</code> 폴더 안에 <code class="language-plaintext highlighter-rouge">predefined_classes.txt</code>라는 파일이 있는데 이 안에는 분류하고 싶은 클래스명을 적어주면 된다.</p>

<p>조작 순서는 <code class="language-plaintext highlighter-rouge">이미지 불러오기 -&gt; 바운딩 박스 생성 -&gt; 저장하기</code> 순이다. 사용법이 직관적이므로 매우 쉽다.</p>

<p>단축키는 주로 이렇게 세 가지를 사용하면 된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">키</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">w</td>
      <td style="text-align: center">박스 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">d</td>
      <td style="text-align: center">다음 이미지</td>
    </tr>
    <tr>
      <td style="text-align: center">a</td>
      <td style="text-align: center">이전 이미지</td>
    </tr>
  </tbody>
</table>

<p>사진 위에 바운딩 박스를 만들고 저장을 누르면 해당 정보가 xml 파일로 저장되는 것을 볼 수 있는데, 우선 한 폴더에 이미지 파일과 메타데이터 파일(xml)을 모아놓자.</p>

<h2 id="-데이터-전처리">🔖 데이터 전처리</h2>

<p>우리가 사용할 모델은 <code class="language-plaintext highlighter-rouge">Object Detection</code>에서 유명한 SSD이다. SSD 모델 구현에 있어서는 <a href="https://github.com/qfgaohao/pytorch-ssd">여기</a>를 참고하였다.</p>

<p>해당 모델을 사용하기 위해서는 위에서 라벨링한 데이터를 모델에 맞게 변형할 필요가 있다.</p>

<p>필수 요소는 이미지 폴더와 그와 관련한 바운딩 박스 정보를 담고 있는 csv 파일이다.</p>

<p>위에서 만든 데이터셋 폴더(이미지+메타데이터)에 <code class="language-plaintext highlighter-rouge">xml_to_csv.py</code>(url 첨부) 파일을 넣고 실행시켜준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 xml_to_csv.py
</code></pre></div></div>

<p>다음과 같이 정리될 것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🗂️ label
sub-test-annotations-bbox.csv
sub-train-annotations-bbox.csv
sub-validation-annotations-bbox.csv
🗂️ <span class="nb">test</span>
🗂️ train
🗂️ validation
</code></pre></div></div>

<p>이제 모델에 넣을 데이터가 준비되었다. 앞으로 이 데이터셋을 <code class="language-plaintext highlighter-rouge">dognose_dataset</code>이라고 부를 것이다.</p>

<h2 id="-모델-훈련">🧭 모델 훈련</h2>

<p>드디어 모델을 학습시켜볼 차례이다. 모델 학습에는 다음 네 가지가 필요하다.</p>

<p>1️⃣ 사전 학습 모델<br />
2️⃣ 코드<br />
3️⃣ 데이터<br />
4️⃣ 개발 환경</p>

<p>이제 이것들을 하나씩 모아볼 것이다.</p>

<p>먼저 우리가 사용할 모델(코드) <code class="language-plaintext highlighter-rouge">pytorch-ssd</code>를 받아오자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/qfgaohao/pytorch-ssd.git
<span class="nb">cd </span>pytorch-ssd
</code></pre></div></div>

<p>해당 코드에서 우리의 데이터를 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">data</code> 폴더를 만들어서 그 안에 <code class="language-plaintext highlighter-rouge">dognose_dataset</code>을 넣어준다.</p>

<p>딥러닝에서 중요한 개념 중 하나가 <code class="language-plaintext highlighter-rouge">전이 학습</code>인데, 기존에 잘 학습된 모델이 있다면 그 모델을 가져와서 추가 학습을 시키는 것이 학습 속도를 크게 단축시키는 하나의 방법으로 알려져있다.</p>

<p><code class="language-plaintext highlighter-rouge">pytorch-ssd</code>에서 <code class="language-plaintext highlighter-rouge">PASCAL VOC</code> 데이터셋에 대해 미리 학습시켜놓은 모델을 제공하고 있으므로 이를 활용할 것이다.</p>

<p>깃허브 페이지에 다운로드 URL이 있으므로 원하는 모델을 다운로드 하면 된다. 필자의 경우 <a href="https://drive.google.com/drive/folders/1pKn-RifvJGWiOx0ZCRLtCXM5GT5lAluu?usp=sharing">mb2-ssd-lite-mp-0_686.pth</a>를 다운로드 하였다. 다운로드를 하였다면 <code class="language-plaintext highlighter-rouge">models</code> 폴더 안에 넣어주면 된다.</p>

<p>사실 사전 학습 모델을 직접 만들어도 좋고, 그냥 베이스 모델을 가지고 우리의 데이터셋을 학습시키는 것도 좋다. 모든 방법을 시도해서(시간이 오래걸리지 않는다면) 가장 좋은 모델을 만들어내는 것이 우리의 목표이기 때문이다.</p>

<p>코드, 사전학습 모델, 데이터. 재료는 다 모은 것 같으므로 이제는 코드를 돌릴 일만 남았다. 하지만 코드를 돌리려면 해당 코드에서 필요로 하는 패키지들을 전부 다운받아야 한다. 문제는 딥러닝을 사용하기 위해서는 정말 많은 라이브러리가 필요하다는 것이다.</p>

<p>많은 개발자들이 <code class="language-plaintext highlighter-rouge">anaconda</code>와 같은 파이썬 배포판을 사용하여 개발 환경을 구축하고 있지만 각종 패키지 간의 호환성을 유지하는 것은 여간 수고가 많이 드는 일이 아니다. 만약 딥러닝 개발환경이 미리 구축되어 있는 환경이 있다면 어떨까?</p>

<p>고맙게도 도커를 사용한다면 이미 많은 사람들이 구축해놓은 개발 환경을 이용할 수 있다. 즉, 복잡한 환경 설정에 신경 쓸 필요없이 모델 학습에만 집중할 수 있다는 얘기다. (물론 개인만의 개발환경을 구축하고 싶다면 직접 구축하는 것이 훨씬 좋다.)</p>

<p>자, 그러면 <a href="https://github.com/ufoym/deepo">deepo</a>라는 유명한 도커 이미지를 사용하여 개발 환경을 구축해보자.</p>

<blockquote>
  <p>Deepo is an open framework to assemble specialized docker images for deep learning research without pain.</p>
</blockquote>

<p>이번 장에서는 CPU를 통한 학습을 기준으로 한다. 로컬에 있는 코드와 사전 학습 모델, 데이터를 전부 활용해야 하므로 현재 위치가 컨테이너 안에 마운트되도록 설정한다. (pytorch-ssd 폴더 안에서 실행해야 한다는 이야기)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull ufoym/deepo:cpu <span class="c"># CPU 전용 이미지 다운로드</span>
docker run <span class="nt">-it</span> <span class="nt">--shm-size</span> 8G <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/mount ufoym/deepo:cpu bash
</code></pre></div></div>

<p>여기서 –shm-size 8G 옵션을 넣어주지 않으면 학습시 다음과 같은 에러를 만나게 되므로 주의하자.</p>

<blockquote>
  <p>RuntimeError: DataLoader worker (pid 938) is killed by signal: Bus error. It is possible that dataloader’s workers are out of shared memory. Please try to raise your shared memory limit.</p>
</blockquote>

<p>이는 데이터로더에 너무 많은 데이터 용량이 올라갔기 때문이다. 메모리 제한을 올려주면 간단히 해결된다.</p>

<p>만약 GPU를 사용하고 싶다면 GPU 전용 도커 이미지와 <code class="language-plaintext highlighter-rouge">nvidia-docker2</code>를 활용하면 된다. 아래는 그 예시이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nvidia-docker2가 설치되었다고 가정</span>
docker pull ufoym/deepo <span class="c"># GPU 전용 이미지 다운로드</span>
docker run <span class="nt">-it</span> <span class="nt">--gpus</span> all <span class="nt">--shm-size</span> 8G <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/mount ufoym/deepo bash
</code></pre></div></div>

<p>Nvidia GPU가 있다면 무조건 활용하는 것이 좋다. CPU와 엄청난 연산 속도 차이를 보이기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">pytorch-ssd</code>를 돌릴 때 추가로 설치해 주어야하는 패키지가 있어서 도커 환경에 접속했다면 아래 패키지를 설치해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ModuleNotFoundError: No module named 'cv2’</span>
pip <span class="nb">install </span>opencv-python
<span class="c"># ImportError: libGL.so.1: cannot open shared object file: No such file or directory</span>
apt-get update
apt-get <span class="nb">install </span>libgl1-mesa-glx
</code></pre></div></div>

<p>혹여나 <code class="language-plaintext highlighter-rouge">exit</code>으로 컨테이너를 빠져나온 뒤에 재접속 하고 싶다면 이렇게 하면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker start 컨테이너ID
<span class="nb">sudo </span>docker attach 컨테이너ID
</code></pre></div></div>

<p>이제 정말 모든 준비를 마쳤다. <code class="language-plaintext highlighter-rouge">pytorch-ssd</code> 페이지를 참고해서 모델 학습을 시작해보자. mount 폴더로 이동하여 아래 명령어를 입력한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python train_ssd.py <span class="nt">--dataset_type</span> open_images <span class="nt">--datasets</span> /mount/data/dognose_dataset <span class="nt">--net</span> mb2-ssd-lite <span class="nt">--pretrained_ssd</span> models/mb2-ssd-lite-mp-0_686.pth <span class="nt">--scheduler</span> cosine <span class="nt">--lr</span> 0.01 <span class="nt">--t_max</span> 100 <span class="nt">--validation_epochs</span> 10 <span class="nt">--num_epochs</span> 100 <span class="nt">--base_net_lr</span> 0.001 <span class="nt">--batch_size</span> 8 <span class="nt">--debug_steps</span> 10
</code></pre></div></div>

<p>딥러닝을 접한지 얼마 안 된 분들이라면 뒤에 붙은 수많은 옵션에 놀라셨을지 모른다. 이는 딥러닝에서 꽤나 중요하게 작용하는 <code class="language-plaintext highlighter-rouge">하이퍼파라미터</code>의 집합이며, 개발자는 이러한 값을 바꿔가며 가능한 모든 시나리오의 조합을 확인한 뒤 가장 좋은 모델을 생성하는 하이퍼파라미터를 찾아낸다. 그렇기에 한번에 최상의 모델이 뚝딱 탄생하는 것은 아니며, 본인이 선택한 파라미터에 따라 모델의 성능은 뒤바뀔 수 있다는 사실을 염두에 두어야한다.</p>

<p>※ 아마 위의 명령어는 원본 코드에서 에러를 발생시킬 것인데, 이것은 모델에 들어가는 데이터의 양식을 필자가 살짝 건드렸기 때문이다. 모든 이미지가 <code class="language-plaintext highlighter-rouge">jpg</code>형식으로 주어지지는 않을 것이라 생각하여 이미지 압축 형식에 영향을 받지 않도록 하였다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ AttributeError: <span class="s1">'NoneType'</span> object has no attribute <span class="s1">'shape'</span>
<span class="c"># /vision/datasets/open_images.py 의 _read_image 함수 수정</span>
🔑 image_file <span class="o">=</span> self.root / self.dataset_type / f<span class="s2">"{image_id}"</span> <span class="c"># &lt;- .jpg 삭제</span>
</code></pre></div></div>

<p>※ 만약 훈련 데이터셋의 길이가 배치 사이즈로 딱 나누어 떨어지지 않는다면 다음과 같은 에러가 발생한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ raise ValueError<span class="o">(</span><span class="s2">"Expected more than 1 value per channel when training, got input size {}"</span>.format<span class="o">(</span>size<span class="o">))</span>
🔑 train_ssd.py 에서 DataLoader 안에 <span class="nv">drop_last</span><span class="o">=</span>True 조건을 추가해준다.
</code></pre></div></div>

<p>정상적으로 훈련이 진행된다면, 데이터셋에 대한 정보가 먼저 나열된 뒤 다음과 같이 Epoch 0부터 모델이 학습을 시작한다.</p>

<p><img src="/assets/img/on-train.png" alt="terminal" /></p>

<p>MacBook Pro 2021년 모델 기준, CPU로 학습시 1 epoch 당 대략 3분 30초 정도 소요되었다. 100 epoch를 전부 학습하는데는 약 9시간 정도가 소요되었다. 물론 GPU로 학습시에는 속도가 비약적으로 빨라질 것으로 예상된다. (훈련 데이터셋은 약 700장이다)</p>

<p>너무 오래걸린다 생각이 되면 10 epoch마다 모델의 check point를 저장해주므로 적당한 loss가 나왔을 때 중지시켜도 된다.</p>

<p>학습이 끝난 뒤 <code class="language-plaintext highlighter-rouge">models</code> 폴더를 보면 mb2-ssd-lite-Epoch-?-Loss-?.pth 형태의 파일이 저장되는데 이것이 바로 우리가 사용할 모델이다.</p>

<h2 id="️-모델-테스트">☑️ 모델 테스트</h2>

<p>모델이 제대로 학습되었는지, 제대로 예측을 하고 있는지 테스트를 해 볼 시간이다.</p>

<p>우선 한 장의 이미지(dog.jpg)를 넣어서 강아지의 코를 잘 찾는지 보자. (pytorch-ssd 폴더 안에 원하는 이미지를 넣는다)</p>

<p>당연한 이야기지만 도커 환경 위에서 실행해야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 run_ssd_example.py mb2-ssd-lite models/mb2-ssd-lite-Epoch-?-Loss-?.pth models/open-images-model-labels.txt dog.jpg
</code></pre></div></div>

<p>open-images-model-labels.txt는 자동 생성되는 파일이지만 <code class="language-plaintext highlighter-rouge">DogNose</code>라벨을 포함하는지 확인하자.</p>

<p>예측이 끝나면 <code class="language-plaintext highlighter-rouge">run_ssd_example_output.jpg</code>라는 이름의 결과 이미지 파일이 생성될 것이다.</p>

<p>아래는 테스트 결과이다.</p>

<div align="center">
    <img src="/assets/img/dog-nose.jpg" alt="dog" width="50%" />
    <figcaption>모델 테스트 결과 (사진 출처: unsplash)</figcaption>
</div>

<p>98%의 확률로 강아지 코를 예측하고 있는 것을 알 수 있다. 나쁘지 않다.</p>

<p>간혹 run_ssd_example.py 파일에서 에러가 나는 경우가 있다. 아래와 같이 해결하자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ cv2.error: OpenCV<span class="o">(</span>4.10.0<span class="o">)</span> :-1: error: <span class="o">(</span><span class="nt">-5</span>:Bad argument<span class="o">)</span> <span class="k">in function</span> <span class="s1">'rectangle'</span>
🔑 <span class="nb">type </span>에러이므로 box[?] 요소를 전부 정수 변환 해준다 -&gt; int<span class="o">(</span>box[?]<span class="o">)</span>
</code></pre></div></div>

<p>또한, 우리가 만든 테스트 데이터셋에 대해서 정확도를 측정하는 것도 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python eval_ssd.py <span class="nt">--dataset_type</span> open_images <span class="nt">--net</span> mb2-ssd-lite <span class="nt">--dataset</span> /mount/data/dognose_dataset <span class="nt">--trained_model</span> models/mb2-ssd-lite-Epoch-?-Loss-?.pth <span class="nt">--label_file</span> models/open-images-model-labels.txt
</code></pre></div></div>

<p>위 명령어를 실행하면 모델이 테스트 데이터셋을 돌면서 예측을 진행하고 마지막에 전체 정확도를 계산해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average Precision Per-class:
DogNose: 0.8976893924291722
Average Precision Across All Classes:0.8976893924291722
</code></pre></div></div>

<p>약 90%의 정확도가 나왔다. 이정도면 나쁘지 않다.</p>

<p>그렇다면 Live로도 잘 판단해줄까? 아래 명령어로 직접 확인해보자.</p>

<p>카메라 권한이 필요하기에 도커보다는 로컬에서 진행하기를 추천한다. <code class="language-plaintext highlighter-rouge">torch</code>, <code class="language-plaintext highlighter-rouge">torchvision</code>, <code class="language-plaintext highlighter-rouge">opencv-python</code> 만 다운로드하면 문제없이 코드를 돌릴 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>torch torchvision opencv-python
python3 run_ssd_live_demo.py mb2-ssd-lite models/mb2-ssd-lite-Epoch-?-Loss-?.pth models/open-images-model-labels.txt
</code></pre></div></div>

<p>카메라가 실행되면 실제 강아지나 사진을 비춰서 모델이 코를 제대로 인식하나 살펴보자.</p>

<p>여기까지 잘 따라왔다면 이젠 PC에서 딥러닝을 돌릴 줄 아는 것이다. 축하한다.</p>

<h2 id="️-모델-변환">🛤️ 모델 변환</h2>

<p>우리가 앞에서 얻은 모델을 앱에 내장하기 위해서는 <code class="language-plaintext highlighter-rouge">.pth</code>로 되어있는 파일 형식을 <code class="language-plaintext highlighter-rouge">.ptl</code>로 바꿔주어야 한다.</p>

<p><a href="https://playtorch.dev/docs/tutorials/prepare-custom-model/">PlayTorch</a> 공식문서에 나와있는 코드를 조금 수정하여 모델 변환 코드를 작성하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># export_model.py
</span><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">from</span> <span class="n">torch.utils.mobile_optimizer</span> <span class="kn">import</span> <span class="n">optimize_for_mobile</span>
<span class="kn">from</span> <span class="n">vision.ssd.mobilenet_v2_ssd_lite</span> <span class="kn">import</span> <span class="n">create_mobilenetv2_ssd_lite</span><span class="p">,</span> <span class="n">create_mobilenetv2_ssd_lite_predictor</span>

<span class="n">model</span> <span class="o">=</span> <span class="nf">create_mobilenetv2_ssd_lite</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">is_test</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">model_path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">models/mb2-ssd-lite-Epoch-?-Loss-?.pth</span><span class="sh">'</span>
<span class="n">model</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

<span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>

<span class="n">scripted_model</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">jit</span><span class="p">.</span><span class="nf">script</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">optimized_model</span> <span class="o">=</span> <span class="nf">optimize_for_mobile</span><span class="p">(</span><span class="n">scripted_model</span><span class="p">)</span>
<span class="n">optimized_model</span><span class="p">.</span><span class="nf">_save_for_lite_interpreter</span><span class="p">(</span><span class="sh">"</span><span class="s">models/mb2-ssd-lite-Epoch-?-Loss-?.ptl</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">model successfully exported</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.ptl</code> 파일을 얻기 위해서는 먼저 <code class="language-plaintext highlighter-rouge">torch.jit</code>을 사용하여 모델을 <code class="language-plaintext highlighter-rouge">Eager mode</code>에서 <code class="language-plaintext highlighter-rouge">Script mode</code>로 변환해주어야 한다. 변환 방법에는 <strong>torch.jit.trace</strong>와 <strong>torch.jit.script</strong> 이렇게 두 가지 방식이 있는데 여기서는 <code class="language-plaintext highlighter-rouge">script</code>를 사용하였다.</p>

<p><code class="language-plaintext highlighter-rouge">trace</code> 방식은 모델 변환시 성공률은 높지만 제대로된 변환을 보장해주지는 않는다. 반면 <code class="language-plaintext highlighter-rouge">script</code> 방식은 모델 구조에 꽤나 엄격하기에 제대로 된 형태가 아닐 경우 에러를 내뿜을 가능성이 높다. 가능하다면 둘 다 시도하여 모델 성능을 비교해보자.</p>

<p>아래는 <code class="language-plaintext highlighter-rouge">script</code>방식에서 자주 마주치는 에러이다. 동적 인덱싱을 사용할 수 없기 때문에 <code class="language-plaintext highlighter-rouge">enumerate</code> 함수로 iterator를 사용하여 해결하거나 integer를 직접 넣어 인덱싱 하는 수밖에 없다.</p>

<blockquote>
  <p>⚠️ ModuleList/Sequential indexing is only supported with integer literals.</p>
</blockquote>

<p>변환을 위해 <code class="language-plaintext highlighter-rouge">/vision/ssd/ssd.py</code>의 <code class="language-plaintext highlighter-rouge">forward</code> 함수를 수정해주었다. 가독성을 조금 해치지만 enumerate를 사용하기 애매한 부분은 for 문을 풀어서 작성하였다.</p>

<p>아래 명령어로 변환을 하였을 때 <code class="language-plaintext highlighter-rouge">model successfully exported</code>라는 말이 나온다면 성공이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 export_model.py
</code></pre></div></div>

<h2 id="-모델-적용">🍿 모델 적용</h2>

<p><a href="https://snack.expo.dev">Snack</a>에서 간단한 코드를 작성한 뒤 <a href="https://playtorch.dev">Playtorch</a> 앱에서 실행시켜볼 계획이었으나 PlayTorch 프로젝트가 사실상 잠정 중단되었기에 이제 이 방법은 불가능하다.</p>

<blockquote>
  <p>This project has been archived and is no longer actively maintained.</p>
</blockquote>

<p>일반적인 앱은 PlayTorch 대신 <a href="https://expo.dev/go">Expo Go</a>에서 돌려볼 수 있으나 <code class="language-plaintext highlighter-rouge">react-native-pytorch-core</code> 라이브러리와의 호환성 문제가 존재하므로 우리의 목적과는 거리가 있다.</p>

<p>따라서 새로운 React Native 프로젝트를 만들어서 테스트 해보는 것이 합리적이다.</p>

<p>준비물은 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>App.js
predictor.js
metro.config.js
mb2-ssd-lite-Epoch-?-Loss-?.ptl
ImageNetClasses.json
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">App.js</code>와 <code class="language-plaintext highlighter-rouge">predictor.js</code>는 <code class="language-plaintext highlighter-rouge">react-native-pytorch-core</code>를 이용하여 React Native 안에서 Tensor를 조작하거나 카메라를 사용하는 컴포넌트를 담고 있다. 이는 <a href="https://playtorch.dev/docs/tutorials/snacks/object-detection/">PlayTorch</a>의 예제들을 살펴보면 쉽게 알 수 있으므로 설명은 생략하겠다.</p>

<p>중요한 것은 우리가 만든 <code class="language-plaintext highlighter-rouge">.ptl</code> 파일을 React Native가 인식하지 못한다는 것인데 이는 <code class="language-plaintext highlighter-rouge">metro.config.js</code>에서 관련 설정을 해주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">getDefaultConfig</span><span class="p">,</span> <span class="nx">mergeConfig</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">@react-native/metro-config</span><span class="dl">"</span><span class="p">);</span>

<span class="cm">/**
 * Metro configuration
 * https://reactnative.dev/docs/metro
 *
 * @type {import('metro-config').MetroConfig}
 */</span>
<span class="kd">const</span> <span class="nx">defaultConfig</span> <span class="o">=</span> <span class="nf">getDefaultConfig</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">defaultAssetExts</span> <span class="o">=</span>
  <span class="nf">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">metro-config/src/defaults/defaults</span><span class="dl">"</span><span class="p">).</span><span class="nx">assetExts</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">resolver</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">assetExts</span><span class="p">:</span> <span class="p">[...</span><span class="nx">defaultAssetExts</span><span class="p">,</span> <span class="dl">"</span><span class="s2">ptl</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">mergeConfig</span><span class="p">(</span><span class="nx">defaultConfig</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
</code></pre></div></div>

<p>설정이 바뀌었으니 이제 metro를 재시작해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm start <span class="nt">--reset-cache</span>
</code></pre></div></div>

<p>혹시나 적용하는 앱에 카메라 접근 권한 설정이 되어있지 않다면 <code class="language-plaintext highlighter-rouge">info.plist</code>에서 관련 권한을 추가해주어야 한다.</p>

<hr />

<h2 id="결론">결론</h2>

<p>이제 모든 과정이 끝났다.</p>

<p>아무래도 핸드폰이라는 제약된 하드웨어 환경에서 딥러닝을 돌리다보니 성능 이슈가 존재할 수 있다. (발열, 끊김 등)</p>

<p>개선의 여지는 있겠지만 아무래도 카메라를 이용하는 Computer Vision 쪽에서는 발열 이슈를 피할 수 없을 것이라 생각한다.</p>

<p>그래도 RAM은 150MB 언저리로 사용하는 것을 보니 엄청난 성능을 필요로 하지는 않는 듯하다.</p>

<div align="center">
    <img src="/assets/img/perf-test.png" alt="dog" width="50%" />
    <figcaption>앱 테스트 결과</figcaption>
</div>

<p>테스트를 해보니 강아지 모형에 대해서는 20%의 확률로 강아지 코라고 인식하고 있었다.😶</p>

<p>실제 강아지를 대상으로 테스트할 경우 정확도가 더 올라갈 수 있다. 다만, 얌전한 강아지를 찾기 힘들다는 문제가 있다.</p>

<p>코드는 <a href="https://github.com/froggydisk/mobileAI">https://github.com/froggydisk/mobileAI</a>에서 볼 수 있으므로 참고를 원하시는 분들은 마음껏 테스트 해보셔도 좋다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Pytorch, React Native, labelImg" /><summary type="html"><![CDATA[앱을 만들다보면 자연스레 AI 기술에 관심을 가지게 된다.]]></summary></entry><entry><title type="html">[FastAPI] API 요청 시 307 Temporary Redirect가 뜨는 이슈</title><link href="http://localhost:4000/fastapi-redirect/" rel="alternate" type="text/html" title="[FastAPI] API 요청 시 307 Temporary Redirect가 뜨는 이슈" /><published>2024-06-15T00:00:00+07:00</published><updated>2024-06-15T00:00:00+07:00</updated><id>http://localhost:4000/fastapi-redirect</id><content type="html" xml:base="http://localhost:4000/fastapi-redirect/"><![CDATA[<p>어느 순간부터 FastAPI 서버에 API 요청을 할 때 status code가 307가 뜨기 시작했다.</p>

<p>분명 쿠버네티스에 띄워놓은 서비스는 잘 돌아가고 있는데 로컬에서만 안되는게 신기했다.</p>

<p>저번에 건드린 <code class="language-plaintext highlighter-rouge">next.config.mjs</code> 파일이 문제가 되었나해서 <code class="language-plaintext highlighter-rouge">rewrite()</code> 함수를 요리조리 건드려 보았지만 여전히 응답은 같았다.</p>

<p>그러던 중 스택오버플로에서 해답을 찾았다. (<a href="https://stackoverflow.com/questions/70351360/keep-getting-307-temporary-redirect-before-returning-status-200-hosted-on-fast">stackoverflow</a>)</p>

<p>FastAPI로 서버를 구성하다보면 보통 API url 끝에 <code class="language-plaintext highlighter-rouge">/</code> 를 붙이는 경우가 많다.</p>

<p>예를 들면 이런 경우다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@app</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"/patients/"</span><span class="o">)</span>
</code></pre></div></div>

<p>보통은 API 요청을 할 때 끝부분에 <code class="language-plaintext highlighter-rouge">/</code>가 있든 없든 문제가 발생하지 않지만 로컬에서는 <code class="language-plaintext highlighter-rouge">/</code>를 빠트리게 되면 <code class="language-plaintext highlighter-rouge">307 Temporary Redirect</code> 이슈가 발생하는 듯하다.</p>

<p>FastAPI는 docs를 제공하므로 백엔드 개발자가 실수할 일이 없으니 프론트 개발자가 API url을 작성할 때 주의하면 되겠다.</p>

<p>결론은 <strong><code class="language-plaintext highlighter-rouge">/</code> 확인을 잘하자</strong>.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Python, FastAPI" /><summary type="html"><![CDATA[어느 순간부터 FastAPI 서버에 API 요청을 할 때 status code가 307가 뜨기 시작했다.]]></summary></entry><entry><title type="html">[Next] 서비스 배포 시 Mixed Content 오류</title><link href="http://localhost:4000/mixed-content/" rel="alternate" type="text/html" title="[Next] 서비스 배포 시 Mixed Content 오류" /><published>2024-06-02T00:00:00+07:00</published><updated>2024-06-02T00:00:00+07:00</updated><id>http://localhost:4000/mixed-content</id><content type="html" xml:base="http://localhost:4000/mixed-content/"><![CDATA[<p>Next.js(@14.2.3)를 활용하여 만든 EMR 데모 버전을 도커로 말아 쿠버네티스에 올렸는데 자꾸 <code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러가 나고 있었다.</p>

<p><code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러는 웹페이지는 <code class="language-plaintext highlighter-rouge">https</code>로 서비스되고 있는데 어떠한 리소스를 <code class="language-plaintext highlighter-rouge">http</code>로 로드하려고 할 때 발생한다.</p>

<p>API URL은 <code class="language-plaintext highlighter-rouge">.env.*</code>에서 관리를 하고 있기 때문에 모든 API 콜에 있어서 동일하게 적용될 터이고 적용한 프로토콜은 분명 <code class="language-plaintext highlighter-rouge">https</code>였다.</p>

<p>구글링 해보면 흔히 나오는 해결 방법은 두 가지이다.</p>

<h3 id="1-헤더-안에-보안-정책-관련-메타-태그를-추가하기">1. 헤더 안에 보안 정책 관련 메타 태그를 추가하기</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// layout.tsx</span>
<span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">Head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">meta</span>
      <span class="nx">httpEquiv</span><span class="o">=</span><span class="dl">"</span><span class="s2">Content-Security-Policy</span><span class="dl">"</span>
      <span class="nx">content</span><span class="o">=</span><span class="dl">"</span><span class="s2">upgrade-insecure-requests</span><span class="dl">"</span>
    <span class="o">/&gt;</span> <span class="c1">// &lt;- add this</span>
  <span class="o">&lt;</span><span class="sr">/Head</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span></code></pre></div></div>

<p>모든 리소스를 강제로 https로 바꿔서 로드하는 것이라 효과가 있을거라 생각했지만 에러가 해결되지는 않았다.</p>

<p><code class="language-plaintext highlighter-rouge">http</code>로 밖에 로드되지 않는 리소스도 분명 있을 것이기에 모든 문제를 해결해주는 만능키는 아니다.</p>

<h3 id="2-next의-프록시-설정-변경">2. Next의 프록시 설정 변경</h3>

<p>처음에는 API URL로 들어갈 때 서버의 <code class="language-plaintext highlighter-rouge">Nginx</code> 안쪽에서 발생하는 리디렉션이 문제일까 하고 여러 설정을 바꿔보았지만 아무런 문제가 없었다.</p>

<p>그렇다면 매우 높은 확률로 클라이언트쪽 문제일 가능성이 높다.</p>

<p>우선, Next는 특정 경로에 대해 프록시를 설정할 수 있는 기능을 제공한다.</p>

<p>이 기능을 사용하는 이유는 여러가지 있을테지만 필자의 경우에는 보통 서버 코드를 변경할 수 없는 경우 <code class="language-plaintext highlighter-rouge">CORS</code> 문제를 해결하기 위해 사용한다.</p>

<p>관련 설정은 <code class="language-plaintext highlighter-rouge">next.config.mjs</code> 파일 안에서 설정해주면 되고, 이번 프로젝트에서는 로컬 컴퓨터에서 PACS 서버에 접근할 때 활용하고 있었다.</p>

<p>코드는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nf">rewrites</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/pacs-api/:path*</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">destination</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://localhost:8042/:path*</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">];</span>
  <span class="p">},</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/pacs-api</code>로 시작하는 URL은 dev 환경에서만 사용하고 있었기에 전혀 의심하지 않고 있었는데 <code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러를 판단함에 있어서 아무래도 source URL과는 상관없이 프로토콜을 우선적으로 적용하는 듯하다.</p>

<p>즉, destination이 <code class="language-plaintext highlighter-rouge">http</code>이기에 해당 웹페이지에서 보내는 모든 리소스 요청은 source와 상관없이 <code class="language-plaintext highlighter-rouge">http</code>로 보내지고 있었다.</p>

<h1 id="결론">결론</h1>

<p>문제를 알았다면 해결은 어렵지 않다. <code class="language-plaintext highlighter-rouge">development</code> 환경에서만 해당 프록시가 동작하도록 바꿔주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nf">rewrites</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">development</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/pacs-api/:path*</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">destination</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://localhost:8042/:path*</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span> <span class="c1">// 다른 환경에서는 리디렉션을 적용하지 않음</span>
  <span class="p">}</span>
<span class="p">},</span>
</code></pre></div></div>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Next" /><summary type="html"><![CDATA[Next.js(@14.2.3)를 활용하여 만든 EMR 데모 버전을 도커로 말아 쿠버네티스에 올렸는데 자꾸 Mixed Content 에러가 나고 있었다.]]></summary></entry><entry><title type="html">[H/W] Mac에서 시리얼 통신하기</title><link href="http://localhost:4000/serial-port/" rel="alternate" type="text/html" title="[H/W] Mac에서 시리얼 통신하기" /><published>2024-04-21T00:00:00+07:00</published><updated>2024-04-21T00:00:00+07:00</updated><id>http://localhost:4000/serial-port</id><content type="html" xml:base="http://localhost:4000/serial-port/"><![CDATA[<p><img src="/assets/img/serial-com.webp" alt="image" /></p>

<p>의료 장비를 맥북과 연결해서 시리얼 통신으로 데이터를 주고 받을 일이 있었다.</p>

<p>요즘은 평소에 시리얼 포트를 보는 것도 드문 일이거니와 과연 M1 칩 이후로는 연동이 잘 되는지도 알 수 없었다.</p>

<p>일단 <code class="language-plaintext highlighter-rouge">RS232-RS232</code> 케이블로 의료 기기에 하나를 꽂아주고 반대편 포트는 맥북의 허브 포트에 꽂을 수 있게 <code class="language-plaintext highlighter-rouge">Serial to USB</code> 어댑터를 연결해준다.</p>

<p>그대로 맥북에 연결하면 다음과 같이 <code class="language-plaintext highlighter-rouge">설정 &gt; 일반 &gt; 시스템 리포트</code> 상에 USB-Serial Controller가 나타난다. 즉, 하드웨어 상으로는 자동으로 연결을 인식해준다.</p>

<p><img src="/assets/img/serial-setting.png" alt="image" /></p>

<p>하지만 코드 상에서 시리얼 통신을 하기 위해서는 <code class="language-plaintext highlighter-rouge">/dev</code> 폴더 아래에 나타나는 장치 코드를 알아내야한다. 보통 <code class="language-plaintext highlighter-rouge">tty~</code>로 시작한다.</p>

<p>터미널에서 검색해보면 아직은 아무것도 나타나지 않는다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /dev/tty<span class="k">*</span>
<span class="c"># /dev/tty.Bluetooth-Incoming-Port</span>
</code></pre></div></div>

<p>아무래도 드라이버가 필요한 듯해서 찾아보았다.</p>

<p>일단 시스템 리포트에 찍히는 <code class="language-plaintext highlighter-rouge">Prolific Technology</code>에서 만든 시리얼 포트를 인식하기 위해서는 드라이버를 다운로드해야 한다.</p>

<p>중국에서 만들었는지 중국어로 된 사이트로 연결이 된다. 관련 macOS(구OSX) 전용 드라이버는 <a href="https://www.prolific.com.tw/US/ShowProduct.aspx?pcid=41&amp;showlevel=0041-0041">Prolific PL2303</a>이다.</p>

<p>하지만 설치를 완료해도 여전히 <code class="language-plaintext highlighter-rouge">/dev</code>에는 아무것도 나타나지 않는다?!</p>

<p>좀 더 검색을 해보니 <code class="language-plaintext highlighter-rouge">Serial to USB</code> 어댑터에도 드라이버가 필요한 듯하다…</p>

<p>이번에는 <code class="language-plaintext highlighter-rouge">FTDI</code>라는 홈페이지에 가서 <code class="language-plaintext highlighter-rouge">Virtual COM port(VCP)</code> 드라이버를 다운받는다.</p>

<blockquote>
  <p><strong>FTDI(Future Technology Devices International)</strong><br />
USB를 시리얼 포트로 변환하는 장치를 생산하는 회사. FTDI의 USB-시리얼 변환기는 컴퓨터의 USB 포트에 연결되어 있고, 시리얼 통신을 지원하는 장치와 통신할 수 있도록 시리얼 데이터를 USB 데이터로 변환한다. 이는 특히 시리얼 포트가 없는 현대의 컴퓨터나 장치와 통신하기 위해 사용된다.</p>
</blockquote>

<p>해당 드라이버는 컴퓨터가 USB 포트로 시리얼 통신을 할 수 있도록 도와주는 역할을 한다.</p>

<p>ARM 전용 dmg 파일을 다운받아서 설치한다. <strong>단, 주의해야할 점은 /Applications 폴더 아래에 놓고 실행을 해야 설치가 된다는 것이다. 이후 <code class="language-plaintext highlighter-rouge">설정 &gt; 개인정보 보호 및 보안</code>에서 관련 권한을 허용해 주어야 한다.</strong></p>

<p>관련 이슈를 <a href="https://www.reddit.com/r/MacOS/comments/17bnhvr/m2_mac_on_macos_sonoma_issues_with_prolific/?utm_source=embedv2&amp;utm_medium=post_embed&amp;utm_content=post_body&amp;embed_host_url=https://embed.notion.co/api/iframe">Reddit</a>에서도 잘 설명해주고 있다.</p>

<p>이제 <code class="language-plaintext highlighter-rouge">/dev</code> 폴더를 살펴보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /dev/tty<span class="k">*</span>
<span class="c"># /dev/tty.Bluetooth-Incoming-Port</span>
<span class="c"># /dev/tty.PL2303G-USBtoUART2130</span>
</code></pre></div></div>

<p>짜잔! 연결된 포트가 나타난다. 이제 관련 라이브러리(예 <a href="https://serialport.io">Node.js</a>)를 이용해서 시리얼 통신을 진행하면 된다.</p>

<p>맥에서 시리얼 통신을 할 때는 드라이버가 필수라는 사실만 알아두자.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Serial Port" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[터미널] Warp + Powerlevel10k + lsd</title><link href="http://localhost:4000/warp/" rel="alternate" type="text/html" title="[터미널] Warp + Powerlevel10k + lsd" /><published>2024-04-10T00:00:00+07:00</published><updated>2024-04-10T00:00:00+07:00</updated><id>http://localhost:4000/warp</id><content type="html" xml:base="http://localhost:4000/warp/"><![CDATA[<h2 id="소개">소개</h2>

<p>기존에는 개발 터미널로 <code class="language-plaintext highlighter-rouge">Iterm2</code>를 쓰고 있었는데 최근에 새로운 터미널을 알게되어 소개하고자 한다.</p>

<p><a href="https://www.warp.dev/a">Warp</a>라는 터미널인데 예전부터 눈여겨보고 있었던 녀석이기는 하다. 슬슬 이쪽으로 트렌드가 넘어오는 느낌도 든다.</p>

<p>추천하는 이유는 다음과 같다.</p>

<ol>
  <li>명령어 자동 완성 기능이 달려있다.</li>
  <li>AI 기능이 내장되어 있다.</li>
  <li>자주 쓰는 워크플로우를 <code class="language-plaintext highlighter-rouge">Warp Drive</code>에 저장해 놓을 수 있다.</li>
  <li>실행 블록별로 찾기, 복사 등 작업이 가능하다.</li>
</ol>

<p>속도는 Terminal.app 보다는 느리지만 Iterm보다는 확실히 빠르다. <a href="https://docs.warp.dev/how-does-warp-compare/performance">벤치마크</a>를 확인해보자.</p>

<p>이는 Warp에서 제공하는 벤치마크이므로 100% 신뢰할 수는 없지만 직접 사용해보니 체감상으로도 빠른 것 같다. 이외에도 편리한 기능이 많다.</p>

<p>단점이라면 zsh를 기본 쉘로 사용하는데 맨 처음 탭을 열 때 zsh 로딩이 조금 느린 정도?</p>

<p>위에 서술한 내용과는 별개로 사실 Warp로 넘어오게 된 이유는 간단하다.</p>

<p>🚀 <strong><code class="language-plaintext highlighter-rouge">터미널이 매우 깔끔하고 멋지다</code></strong></p>

<p><img src="/assets/img/warp.png" alt="image" /></p>

<hr />

<h2 id="설치">설치</h2>

<h3 id="-warp">● Warp</h3>

<p>우선 <a href="https://www.warp.dev/a">Warp 사이트</a>로 이동하여 다운받는다. 혹은 <code class="language-plaintext highlighter-rouge">brew install</code>도 가능하다.</p>

<p>설치 후 실행하면 바로 사용할 수 있다. 기존 테마도 멋있지만 커스텀 테마를 적용하는 것도 가능하다.</p>

<p>커스텀 테마는 <a href="https://terminal-themes.com/">관련 사이트</a>에서 다운받거나 yaml 파일을 직접 작성하여 적용할 수 있다.</p>

<p>필자는 <code class="language-plaintext highlighter-rouge">Seashell.yaml</code>을 다운 받아서 적용하였다. 테마 관련 폴더를 생성해서 그 안에 다운로드 받은 yaml 파일을 옮겨주면 된다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.warp/themes/
<span class="nb">cp</span> ~/Downloads/.yaml ~/.warp/themes/
</code></pre></div></div>

<p>이제 Warp 테마 설정에서 해당 테마 선택이 가능하다.</p>

<p><a href="https://docs.warp.dev/appearance/custom-themes">공식문서</a>에서도 커스텀 테마 적용 방법에 대해 상세히 설명하고 있으므로 한번 살펴보자.</p>

<h3 id="-powerlevel10k">● Powerlevel10k</h3>

<p>Iterm2를 사용할 때 zsh 프롬프트를 꾸며주기 위해 <code class="language-plaintext highlighter-rouge">powerlevel10k</code>를 적용했었는데 Warp도 zsh를 사용하므로 동일하게 적용이 가능하다.</p>

<p>기존에 Iterm2를 사용하시던 분이라면 자동으로 적용이 될 것이다.</p>

<p>Warp에서도 친절하게 <a href="https://www.warp.dev/blog/how-to-set-up-powerlevel10k-on-warp#setup">powerlevel10k를 적용하는 방법</a>에 대해서 설명해주고 있다.</p>

<p>p10k를 설치하기에 앞서 터미널 상에서 아이콘들이 제대로 나타나기 위해서 폰트를 적용해주어야 한다.</p>

<p>절차는 다음과 같다.</p>

<ol>
  <li><a href="https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#manual">Powerlevel10k 공식 깃허브 페이지</a>에서 MesloLGS NF 폰트를 다운로드한다. Regular, Bold, Italic, Bold Italic.ttf 파일을 모두 다운받아서 설치해준다.</li>
  <li>Warp의 설정에서 <code class="language-plaintext highlighter-rouge">Appearance &gt; Text</code> 로 이동한 뒤 <code class="language-plaintext highlighter-rouge">View all available system fonts</code> 박스를 체크해주고 드롭다운 메뉴에서 <code class="language-plaintext highlighter-rouge">MesloLGS NF</code> 폰트를 선택한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Appearance &gt; Prompt</code> 에서 <code class="language-plaintext highlighter-rouge">Sheell prompt (PS1)</code>을 골라준다.</li>
</ol>

<p>이제 p10k를 설치해보자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--depth</span><span class="o">=</span>1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k
<span class="nb">echo</span> <span class="s1">'source ~/powerlevel10k/powerlevel10k.zsh-theme'</span> <span class="o">&gt;&gt;</span>~/.zshrc
</code></pre></div></div>

<p>설치가 완료되었다면 <code class="language-plaintext highlighter-rouge">exec zsh</code> 명령어로 테마 설정 마법사를 시작한다. 만일 설정창이 뜨지 않는다면 <code class="language-plaintext highlighter-rouge">p10k configure</code> 명령어를 활용한다.</p>

<p>이제 설정 마법사가 안내해 주는대로 개인의 취향에 맞게 설정해주면 된다.</p>

<h3 id="-lsd">● lsd</h3>

<p>아이콘 얘기가 나왔으니 <code class="language-plaintext highlighter-rouge">ls</code> 명령어를 입력했을 때 나오는 결과값에도 아이콘을 입혀보자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설치</span>
<span class="nv">$ </span>brew <span class="nb">install </span>lsd

<span class="c"># alias 설정</span>
<span class="nv">$ </span>vi ~/.zshrc

<span class="nb">alias ls</span><span class="o">=</span><span class="s1">'lsd'</span>
<span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -alhF'</span>
<span class="nb">alias </span><span class="nv">lt</span><span class="o">=</span><span class="s1">'ls --tree'</span>

<span class="nv">$ </span><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>

<p>이제 ls 명령을 입력하면 파일과 디렉토리의 차이가 한눈에 들어온다. 각 파일의 형태에 따라 아이콘이 다르게 표시되는 것도 볼 수 있다.</p>

<p><img src="/assets/img/lsd.png" alt="image" /></p>

<h3 id="-탭-이름-설정하기">● 탭 이름 설정하기</h3>

<p>Warp에서 탭을 열었을 때는 현재 경로가 탭 이름으로 표시되게 된다. 경로가 길 때는 잘 보이지 않으니 그냥 랜덤한 이모티콘으로 바꿔주자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim ~/.zshrc
</code></pre></div></div>

<p>참고하고 싶은 분을 위해 .zshrc의 내용을 그대로 가져왔다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.</span>
<span class="c"># Initialization code that may require console input (password prompts, [y/n]</span>
<span class="c"># confirmations, etc.) must go above this block; everything else may go below.</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nt">-r</span> <span class="s2">"</span><span class="k">${</span><span class="nv">XDG_CACHE_HOME</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.cache</span><span class="k">}</span><span class="s2">/p10k-instant-prompt-</span><span class="k">${</span><span class="p">(%)</span><span class="k">:-</span><span class="p">%n</span><span class="k">}</span><span class="s2">.zsh"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">source</span> <span class="s2">"</span><span class="k">${</span><span class="nv">XDG_CACHE_HOME</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.cache</span><span class="k">}</span><span class="s2">/p10k-instant-prompt-</span><span class="k">${</span><span class="p">(%)</span><span class="k">:-</span><span class="p">%n</span><span class="k">}</span><span class="s2">.zsh"</span>
<span class="k">fi</span>

<span class="c"># ================================================= 이 부분 추가</span>
<span class="c"># set tab name randomly when a new tab is open</span>
<span class="k">function </span>set_name <span class="o">()</span> <span class="o">{</span>
  <span class="nv">emojis</span><span class="o">=(</span><span class="s2">"⚡️"</span> <span class="s2">"🔥"</span> <span class="s2">"👑"</span> <span class="s2">"🍻"</span> <span class="s2">"🚀"</span> <span class="s2">"💡"</span> <span class="s2">"🎉"</span> <span class="s2">"🌙"</span><span class="o">)</span>
  <span class="nv">RAND_EMOJI_N</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$RANDOM</span> <span class="o">%</span> <span class="k">${#</span><span class="nv">emojis</span><span class="p">[@]</span><span class="k">}</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
  <span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33]0;</span><span class="k">${</span><span class="nv">emojis</span><span class="p">[RAND_EMOJI_N]</span><span class="k">}</span><span class="se">\0</span><span class="s2">07"</span>
<span class="o">}</span>
<span class="c"># if the terminal is Zsh, then run set_name</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$ZSH_VERSION</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>precmd_functions+<span class="o">=(</span>set_name<span class="o">)</span>
<span class="k">fi</span>
<span class="c"># =================================================</span>

<span class="c"># set aliases for lsd package</span>
<span class="nb">alias ls</span><span class="o">=</span><span class="s1">'lsd'</span>
<span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -alhF'</span>
<span class="nb">alias </span><span class="nv">lt</span><span class="o">=</span><span class="s1">'ls --tree'</span>

<span class="nb">eval</span> <span class="si">$(</span>/opt/homebrew/bin/brew shellenv<span class="si">)</span>
<span class="nb">source</span> ~/powerlevel10k/powerlevel10k.zsh-theme

<span class="c"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span>
<span class="o">[[</span> <span class="o">!</span> <span class="nt">-f</span> ~/.p10k.zsh <span class="o">]]</span> <span class="o">||</span> <span class="nb">source</span> ~/.p10k.zsh
</code></pre></div></div>

<p>이제 적용해주면 된다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>

<h3 id="-vim-커스텀-테마">● Vim 커스텀 테마</h3>

<p>이제 웬만한 부분은 완성되었다.</p>

<p>Mac을 사용하다보면 <code class="language-plaintext highlighter-rouge">Vim</code>을 텍스트 편집기로 사용하게 되는데 좀 더 완벽을 기한다면 Vim 커스텀 테마까지 적용해보자. 문서 읽기가 매우 편해진다.</p>

<p>Warp 커스텀 테마 때와 마찬가지로 <a href="https://vimcolorschemes.com/top/">사이트</a>에서 원하는 테마를 다운받는다.</p>

<p>테마 관련 폴더를 생성해서 다운로드받은 파일을 옮겨준다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/.vim/colors
<span class="nb">cp</span> ~/Downloads/.yaml ~/.vim/colors/
vim ~/.vimrc
</code></pre></div></div>

<p>아래와 같이 설정해준다. 비어있다면 복사-붙여넣기를 한다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">" Syntax Highlighting
if has("</span>syntax<span class="s2">")
    syntax on
endif

set ts=4
set autoindent

colo  // &lt;- colors 안에 들어있는 .vim 파일명

set laststatus=2
set statusline=</span><span class="se">\ </span><span class="s2">%&lt;%l:%v</span><span class="se">\ </span><span class="s2">[%P]%=%a</span><span class="se">\ </span><span class="s2">%h%m%r</span><span class="se">\ </span><span class="s2">%F</span><span class="se">\</span><span class="s2">
</span></code></pre></div></div>

<p>vim을 재실행하면 테마가 적용된다.</p>

<p><img src="/assets/img/vim.png" alt="image" /></p>

<h2 id="결론">결론</h2>

<p>이제 VScode만 깔아준다면 개발 준비는 끝난 것이다.</p>

<p>다른거는 몰라도 <code class="language-plaintext highlighter-rouge">Warp + Powerlevel10k</code> 조합은 꼭 적용해보자. 할 일이 없어도 터미널을 켜고 있는 자신을 발견할 것이다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Mac, Terminal" /><summary type="html"><![CDATA[소개]]></summary></entry></feed>