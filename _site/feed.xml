<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2024-07-08T15:01:00+07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">froggydisk</title><subtitle>This is for frogs in the world.</subtitle><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><entry><title type="html">[RN/AI] Pytorch로 AI 모델을 학습시켜 모바일 앱에 적용하기</title><link href="http://localhost:4000/ai-on-app-intro/" rel="alternate" type="text/html" title="[RN/AI] Pytorch로 AI 모델을 학습시켜 모바일 앱에 적용하기" /><published>2024-06-30T00:00:00+07:00</published><updated>2024-06-30T00:00:00+07:00</updated><id>http://localhost:4000/ai-on-app-intro</id><content type="html" xml:base="http://localhost:4000/ai-on-app-intro/"><![CDATA[<h2 id="현재-작성중인-글입니다">[현재 작성중인 글입니다.]</h2>

<p>앱을 만들다보면 자연스레 AI 기술에 관심을 가지게 된다.</p>

<p>“요즘 chatGPT가 그렇게 핫하다는데 나도 AI 좀 접목시켜 볼까…?” 라는 상상을 하게 된다</p>

<p>그렇다면 어떻게 해야할까? 하나하나 차근차근 파헤쳐보자.</p>

<p>(예시 영상)</p>

<p>(Object Detection 설명)</p>

<p>(필요 스펙 테이블)</p>

<h2 id="-프로세스">🍀 프로세스</h2>

<p>전체적인 흐름은 다음과 같다.</p>

<p><img src="/assets/img/ai-on-app-process.png" alt="이미지" /></p>

<h3 id="1-데이터-라벨링">1. 데이터 라벨링</h3>

<p>AI 모델을 훈련시키기 위해서는 그에 적합한 데이터가 필요하다.</p>

<p>오픈소스 데이터를 활용하는 것이 가장 좋지만, 원하는 데이터가 없다면 직접 만들 수밖에 없다.</p>

<p>여기서는 <code class="language-plaintext highlighter-rouge">labelImg</code>라는 라벨러를 사용하여 데이터를 직접 만들어볼 것이다.</p>

<p>(이 과정이 정 귀찮다면 파인튜닝된 모델을 깃허브, 허깅페이스 같은 곳에서 받아와서 사용해도 좋다.)</p>

<h3 id="2-데이터-전처리">2. 데이터 전처리</h3>

<p>모델을 학습시키는 데이터의 형식에는 여러가지가 있지만 우리가 만들 모델은 csv를 필요로 하기에 xml 형태의 데이터를 csv로 변환할 것이다.</p>

<p>실전에서는 원하는 모델의 형식에 맞게 데이터셋을 변형해보자.</p>

<h3 id="3-모델-훈련">3. 모델 훈련</h3>

<p>만들어 놓은 데이터셋으로 모델을 학습시켜본다.</p>

<p>GPU가 있으면 더 빠르고 좋지만, CPU로도 나름 괜찮은 모델을 학습할 수 있다.</p>

<p>우리는 도커를 통해 딥러닝용 가상환경 위에서 학습을 진행할 것이다.</p>

<h3 id="4-모델-테스트">4. 모델 테스트</h3>

<p>의도한대로 잘 학습이 진행되었는지, 정확도는 얼마인지, 실제로 잘 작동하는지 확인한다.</p>

<p>더불어 라이브 테스트도 진행해보자.</p>

<h3 id="5-모델-변형">5. 모델 변형</h3>

<p>우리가 훈련시킨 모델을 모바일 앱에서 사용하기 위해서는 특정 형식이 필요하다.</p>

<p>모델 파일 형식이 <code class="language-plaintext highlighter-rouge">.pth</code>로 되어있을텐데, 이를 <code class="language-plaintext highlighter-rouge">.ptl</code>파일로 변경해주어야 한다.</p>

<p>이 과정에서 <code class="language-plaintext highlighter-rouge">torch.jit</code>을 통한 모델 튜닝에 관한 이야기를 할 것이다.</p>

<h3 id="6-모델-적용">6. 모델 적용</h3>

<p>해당 모델을 <code class="language-plaintext highlighter-rouge">Snack</code>에서 확인해보고, 실제로 <code class="language-plaintext highlighter-rouge">React Native</code> 프로젝트에도 적용해보자.</p>

<p>결과물을 보고 모델 최적화에 대해서도 고민해보자.</p>

<p><br /></p>

<hr />

<h2 id="️-데이터-라벨링-data-labeling">🏷️ 데이터 라벨링 (Data Labeling)</h2>

<p>모델 학습에 필요한 데이터를 만들기 위해서는 원본(raw) 데이터와 라벨링 툴이 필요하다.
(*Object Detection에 필요한 데이터는 원본 이미지와 바운딩 박스에 관한 좌표 정보이다.)</p>

<p>먼저 원본 데이터부터 준비하자.</p>

<p>원본 데이터는 <a href="http://vision.stanford.edu/aditya86/ImageNetDogs/">Stanford Dogs Dataset</a>을 사용할 것이다. 120종의 강아지 사진 총 20,580장이 모여있는 데이터셋이다.</p>

<p>모든 이미지를 사용할 필요는 없고, 원하는만큼 이미지를 특정 폴더로 옮겨준다. (모델 성능이 잘 안나올 경우 나중에 더 많은 데이터를 가져오면 되므로 일단은 조금만 옮겨보자. 물론 층화 샘플링(Stratified Sampling)을 해주면 가장 좋다.)</p>

<p>해당 폴더는 이제 새로운 데이터셋 폴더로 사용될 것이다.</p>

<p>기본 데이터가 준비되었다면 이제 <a href="https://github.com/HumanSignal/labelImg">labelImg</a>라는 툴을 소개하고자 한다. 간단히 설명하자면 다음과 같다.</p>

<blockquote>
  <p>Object Detection 모델 학습에 필요한 주석(Annotation) 처리된 이미지를 생성할 수 있게 도와주는 도구이다.</p>
</blockquote>

<p>깃허브 페이지에 들어가보면 설치 및 사용 방법에 대해 상세히 설명하고 있다.</p>

<p>단, 필자는 <code class="language-plaintext highlighter-rouge">M1 Pro chip MacBook Pro 14</code>를 사용하고 있는데 설치 가이드에 부족한 내용이 있어 관련 내용을 추가한다.</p>

<p><strong>⚠️ pyrcc5: No such file or directory</strong> 혹 이러한 에러를 만난다면 아래 코드대로 설치한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>qt qt@5
brew <span class="nb">install </span>libxml2
brew <span class="nb">install </span>pyqt@5
pip3 <span class="nb">install </span>pyqt5 lxml
git clone https://github.com/HumanSignal/labelImg.git
<span class="nb">cd </span>labelImg
make qt5py3
python3 labelImg.py
</code></pre></div></div>

<p>실행 화면은 아래와 같다.</p>

<p><img src="/assets/img/labelImg.png" alt="labelImg" /></p>

<p><code class="language-plaintext highlighter-rouge">labelImg/data</code> 폴더 안에 <code class="language-plaintext highlighter-rouge">predefined_classes.txt</code>라는 파일이 있는데 이 안에는 분류하고 싶은 클래스명을 적어주면 된다.</p>

<p>조작 순서는 <code class="language-plaintext highlighter-rouge">이미지 불러오기 -&gt; 바운딩 박스 생성 -&gt; 저장하기</code> 순이다. 사용법이 직관적이므로 매우 쉽다.</p>

<p>단축키는 주로 이렇게 세 가지를 사용하면 된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">키</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">w</td>
      <td style="text-align: center">박스 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">d</td>
      <td style="text-align: center">다음 이미지</td>
    </tr>
    <tr>
      <td style="text-align: center">a</td>
      <td style="text-align: center">이전 이미지</td>
    </tr>
  </tbody>
</table>

<p>사진 위에 바운딩 박스를 만들고 저장을 누르면 해당 정보가 xml 파일로 저장되는 것을 볼 수 있는데, 우선 한 폴더에 이미지 파일과 메타데이터 파일(xml)을 모아놓자.</p>

<h2 id="-데이터-전처리">🔖 데이터 전처리</h2>

<p>우리가 사용할 모델은 <code class="language-plaintext highlighter-rouge">Object Detection</code>에서 유명한 SSD이다. SSD 모델 구현에 있어서는 <a href="https://github.com/qfgaohao/pytorch-ssd">여기</a>를 참고하였다.</p>

<p>해당 모델을 사용하기 위해서는 위에서 라벨링한 데이터를 모델에 맞게 변형할 필요가 있다.</p>

<p>필수 요소는 이미지 폴더와 그와 관련한 바운딩 박스 정보를 담고 있는 csv 파일이다.</p>

<p>위에서 만든 데이터셋 폴더(이미지+메타데이터)에 <code class="language-plaintext highlighter-rouge">xml_to_csv.py</code>(url 첨부) 파일을 넣고 실행시켜준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 xml_to_csv.py
</code></pre></div></div>

<p>다음과 같이 정리될 것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🗂️ label
sub-test-annotations-bbox.csv
sub-train-annotations-bbox.csv
sub-validation-annotations-bbox.csv
🗂️ <span class="nb">test</span>
🗂️ train
🗂️ validation
</code></pre></div></div>

<p>이제 모델에 넣을 데이터가 준비되었다. 앞으로 이 데이터셋을 <code class="language-plaintext highlighter-rouge">dognose_dataset</code>이라고 부를 것이다.</p>

<h2 id="-모델-훈련">🧭 모델 훈련</h2>

<p>드디어 모델을 학습시켜볼 차례이다. 모델 학습에는 다음 네 가지가 필요하다.</p>

<p>1️⃣ 사전 학습 모델<br />
2️⃣ 코드<br />
3️⃣ 데이터<br />
4️⃣ 개발 환경</p>

<p>이제 이것들을 하나씩 모아볼 것이다.</p>

<p>먼저 우리가 사용할 모델(코드) <code class="language-plaintext highlighter-rouge">pytorch-ssd</code>를 받아오자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/qfgaohao/pytorch-ssd.git
<span class="nb">cd </span>pytorch-ssd
</code></pre></div></div>

<p>해당 코드에서 우리의 데이터를 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">data</code> 폴더를 만들어서 그 안에 <code class="language-plaintext highlighter-rouge">dognose_dataset</code>을 넣어준다.</p>

<p>딥러닝에서 중요한 개념 중 하나가 <code class="language-plaintext highlighter-rouge">전이 학습</code>인데, 기존에 잘 학습된 모델이 있다면 그 모델을 가져와서 추가 학습을 시키는 것이 학습 속도를 크게 단축시키는 하나의 방법으로 알려져있다.</p>

<p><code class="language-plaintext highlighter-rouge">pytorch-ssd</code>에서 <code class="language-plaintext highlighter-rouge">PASCAL VOC</code> 데이터셋에 대해 미리 학습시켜놓은 모델을 제공하고 있으므로 이를 활용할 것이다.</p>

<p>깃허브 페이지에 다운로드 URL이 있으므로 원하는 모델을 다운로드 하면 된다. 필자의 경우 <a href="https://drive.google.com/drive/folders/1pKn-RifvJGWiOx0ZCRLtCXM5GT5lAluu?usp=sharing">mb2-ssd-lite-mp-0_686.pth</a>를 다운로드 하였다. 다운로드를 하였다면 <code class="language-plaintext highlighter-rouge">models</code> 폴더 안에 넣어주면 된다.</p>

<p>사실 사전 학습 모델을 직접 만들어도 좋고, 그냥 베이스 모델을 가지고 우리의 데이터셋을 학습시키는 것도 좋다. 모든 방법을 시도해서(시간이 오래걸리지 않는다면) 가장 좋은 모델을 만들어내는 것이 우리의 목표이기 때문이다.</p>

<p>코드, 사전학습 모델, 데이터. 재료는 다 모은 것 같으므로 이제는 코드를 돌릴 일만 남았다. 하지만 코드를 돌리려면 해당 코드에서 필요로 하는 패키지들을 전부 다운받아야 한다. 문제는 딥러닝을 사용하기 위해서는 정말 많은 라이브러리가 필요하다는 것이다.</p>

<p>많은 개발자들이 <code class="language-plaintext highlighter-rouge">anaconda</code>와 같은 파이썬 배포판을 사용하여 개발 환경을 구축하고 있지만 각종 패키지 간의 호환성을 유지하는 것은 여간 수고가 많이 드는 일이 아니다. 만약 딥러닝 개발환경이 미리 구축되어 있는 환경이 있다면 어떨까?</p>

<p>고맙게도 도커를 사용한다면 이미 많은 사람들이 구축해놓은 개발 환경을 이용할 수 있다. 즉, 복잡한 환경 설정에 신경 쓸 필요없이 모델 학습에만 집중할 수 있다는 얘기다. (물론 개인만의 개발환경을 구축하고 싶다면 직접 구축하는 것이 훨씬 좋다.)</p>

<p>자, 그러면 <a href="https://github.com/ufoym/deepo">deepo</a>라는 유명한 도커 이미지를 사용하여 개발 환경을 구축해보자.</p>

<blockquote>
  <p>Deepo is an open framework to assemble specialized docker images for deep learning research without pain.</p>
</blockquote>

<p>이번 장에서는 CPU를 통한 학습을 기준으로 한다. 로컬에 있는 코드와 사전 학습 모델, 데이터를 전부 활용해야 하므로 현재 위치가 컨테이너 안에 마운트되도록 설정한다. (pytorch-ssd 폴더 안에서 실행해야 한다는 이야기)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull ufoym/deepo:cpu <span class="c"># CPU 전용 이미지 다운로드</span>
docker run <span class="nt">-it</span> <span class="nt">--shm-size</span> 8G <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/mount ufoym/deepo:cpu bash
</code></pre></div></div>

<p>여기서 –shm-size 8G 옵션을 넣어주지 않으면 학습시 다음과 같은 에러를 만나게 되므로 주의하자.</p>

<blockquote>
  <p>RuntimeError: DataLoader worker (pid 938) is killed by signal: Bus error. It is possible that dataloader’s workers are out of shared memory. Please try to raise your shared memory limit.</p>
</blockquote>

<p>이는 데이터로더에 너무 많은 데이터 용량이 올라갔기 때문이다. 메모리 제한을 올려주면 간단히 해결된다.</p>

<p>만약 GPU를 사용하고 싶다면 GPU 전용 도커 이미지와 <code class="language-plaintext highlighter-rouge">nvidia-docker2</code>를 활용하면 된다. 아래는 그 예시이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nvidia-docker2가 설치되었다고 가정</span>
docker pull ufoym/deepo <span class="c"># GPU 전용 이미지 다운로드</span>
docker run <span class="nt">-it</span> <span class="nt">--gpus</span> all <span class="nt">--shm-size</span> 8G <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">"</span>:/mount ufoym/deepo bash
</code></pre></div></div>

<p>Nvidia GPU가 있다면 무조건 활용하는 것이 좋다. CPU와 엄청난 연산 속도 차이를 보이기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">pytorch-ssd</code>를 돌릴 때 추가로 설치해 주어야하는 패키지가 있어서 도커 환경에 접속했다면 아래 패키지를 설치해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ModuleNotFoundError: No module named 'cv2’</span>
pip <span class="nb">install </span>opencv-python
<span class="c"># ImportError: libGL.so.1: cannot open shared object file: No such file or directory</span>
apt-get update
apt-get <span class="nb">install </span>libgl1-mesa-glx
</code></pre></div></div>

<p>혹여나 <code class="language-plaintext highlighter-rouge">exit</code>으로 컨테이너를 빠져나온 뒤에 재접속 하고 싶다면 이렇게 하면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker start 컨테이너ID
<span class="nb">sudo </span>docker attach 컨테이너ID
</code></pre></div></div>

<p>이제 정말 모든 준비를 마쳤다. <code class="language-plaintext highlighter-rouge">pytorch-ssd</code> 페이지를 참고해서 모델 학습을 시작해보자. mount 폴더로 이동하여 아래 명령어를 입력한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python train_ssd.py <span class="nt">--dataset_type</span> open_images <span class="nt">--datasets</span> /mount/data/dognose_dataset <span class="nt">--net</span> mb2-ssd-lite <span class="nt">--pretrained_ssd</span> models/mb2-ssd-lite-mp-0_686.pth <span class="nt">--scheduler</span> cosine <span class="nt">--lr</span> 0.01 <span class="nt">--t_max</span> 100 <span class="nt">--validation_epochs</span> 10 <span class="nt">--num_epochs</span> 100 <span class="nt">--base_net_lr</span> 0.001 <span class="nt">--batch_size</span> 8 <span class="nt">--debug_steps</span> 10
</code></pre></div></div>

<p>딥러닝을 접한지 얼마 안 된 분들이라면 뒤에 붙은 수많은 옵션에 놀라셨을지 모른다. 이는 딥러닝에서 꽤나 중요하게 작용하는 <code class="language-plaintext highlighter-rouge">하이퍼파라미터</code>의 집합이며, 개발자는 이러한 값을 바꿔가며 가능한 모든 시나리오의 조합을 확인한 뒤 가장 좋은 모델을 생성하는 하이퍼파라미터를 찾아낸다. 그렇기에 한번에 최상의 모델이 뚝딱 탄생하는 것은 아니며, 본인이 선택한 파라미터에 따라 모델의 성능은 뒤바뀔 수 있다는 사실을 염두에 두어야한다.</p>

<p>※ 아마 위의 명령어는 원본 코드에서 에러를 발생시킬 것인데, 이것은 모델에 들어가는 데이터의 양식을 필자가 살짝 건드렸기 때문이다. 모든 이미지가 <code class="language-plaintext highlighter-rouge">jpg</code>형식으로 주어지지는 않을 것이라 생각하여 이미지 압축 형식에 영향을 받지 않도록 하였다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ AttributeError: <span class="s1">'NoneType'</span> object has no attribute <span class="s1">'shape'</span>
<span class="c"># /vision/datasets/open_images.py 의 _read_image 함수 수정</span>
🔑 image_file <span class="o">=</span> self.root / self.dataset_type / f<span class="s2">"{image_id}"</span> <span class="c"># &lt;- .jpg 삭제</span>
</code></pre></div></div>

<p>※ 만약 훈련 데이터셋의 길이가 배치 사이즈로 딱 나누어 떨어지지 않는다면 다음과 같은 에러가 발생한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ raise ValueError<span class="o">(</span><span class="s2">"Expected more than 1 value per channel when training, got input size {}"</span>.format<span class="o">(</span>size<span class="o">))</span>
🔑 train_ssd.py 에서 DataLoader 안에 <span class="nv">drop_last</span><span class="o">=</span>True 조건을 추가해준다.
</code></pre></div></div>

<p>정상적으로 훈련이 진행된다면, 데이터셋에 대한 정보가 먼저 나열된 뒤 다음과 같이 Epoch 0부터 모델이 학습을 시작한다.</p>

<p><img src="/assets/img/on-train.png" alt="terminal" /></p>

<p>MacBook Pro 2021년 모델 기준, CPU로 학습시 1 epoch 당 대략 3분 30초 정도 소요되었다. 100 epoch를 전부 학습하는데는 약 9시간 정도가 소요되었다. 물론 GPU로 학습시에는 속도가 비약적으로 빨라질 것으로 예상된다. (훈련 데이터셋은 약 700장이다)</p>

<p>너무 오래걸린다 생각이 되면 10 epoch마다 모델의 check point를 저장해주므로 적당한 loss가 나왔을 때 중지시켜도 된다.</p>

<p>학습이 끝난 뒤 <code class="language-plaintext highlighter-rouge">models</code> 폴더를 보면 mb2-ssd-lite-Epoch-?-Loss-?.pth 형태의 파일이 저장되는데 이것이 바로 우리가 사용할 모델이다.</p>

<h2 id="️-모델-테스트">☑️ 모델 테스트</h2>

<p>모델이 제대로 학습되었는지, 제대로 예측을 하고 있는지 테스트를 해 볼 시간이다.</p>

<p>우선 한 장의 이미지(dog.jpg)를 넣어서 강아지의 코를 잘 찾는지 보자. (pytorch-ssd 폴더 안에 원하는 이미지를 넣는다)</p>

<p>당연한 이야기지만 도커 환경 위에서 실행해야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 run_ssd_example.py mb2-ssd-lite models/mb2-ssd-lite-Epoch-?-Loss-?.pth models/open-images-model-labels.txt dog.jpg
</code></pre></div></div>

<p>open-images-model-labels.txt는 자동 생성되는 파일이지만 <code class="language-plaintext highlighter-rouge">DogNose</code>라벨을 포함하는지 확인하자.</p>

<p>예측이 끝나면 <code class="language-plaintext highlighter-rouge">run_ssd_example_output.jpg</code>라는 이름의 결과 이미지 파일이 생성될 것이다.</p>

<p>아래는 테스트 결과이다.</p>

<figure style="width: 50%; margin: auto; text-align: center;">
    <img src="/assets/img/dog-nose.jpg" alt="dog" />
    <figcaption>모델 테스트 결과 (사진 출처: unsplash)</figcaption>
</figure>

<p>98%의 확률로 강아지 코를 예측하고 있는 것을 알 수 있다. 나쁘지 않다.</p>

<p>간혹 run_ssd_example.py 파일에서 에러가 나는 경우가 있다. 아래와 같이 해결하자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠️ cv2.error: OpenCV<span class="o">(</span>4.10.0<span class="o">)</span> :-1: error: <span class="o">(</span><span class="nt">-5</span>:Bad argument<span class="o">)</span> <span class="k">in function</span> <span class="s1">'rectangle'</span>
🔑 <span class="nb">type </span>에러이므로 box[?] 요소를 전부 정수 변환 해준다 -&gt; int<span class="o">(</span>box[?]<span class="o">)</span>
</code></pre></div></div>

<p>또한, 우리가 만든 테스트 데이터셋에 대해서 정확도를 측정하는 것도 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python eval_ssd.py <span class="nt">--dataset_type</span> open_images <span class="nt">--net</span> mb2-ssd-lite <span class="nt">--dataset</span> /mount/data/dognose_dataset <span class="nt">--trained_model</span> models/mb2-ssd-lite-Epoch-?-Loss-?.pth <span class="nt">--label_file</span> models/open-images-model-labels.txt
</code></pre></div></div>

<p>위 명령어를 실행하면 모델이 테스트 데이터셋을 돌면서 예측을 진행하고 마지막에 전체 정확도를 계산해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average Precision Per-class:
DogNose: 0.8976893924291722
Average Precision Across All Classes:0.8976893924291722
</code></pre></div></div>

<p>약 90%의 정확도가 나왔다. 이정도면 나쁘지 않다.</p>

<p>그렇다면 Live로도 잘 판단해줄까? 아래 명령어로 직접 확인해보자.</p>

<p>카메라 권한이 필요하기에 도커보다는 로컬에서 진행하기를 추천한다. <code class="language-plaintext highlighter-rouge">torch</code>, <code class="language-plaintext highlighter-rouge">torchvision</code>, <code class="language-plaintext highlighter-rouge">opencv-python</code> 만 다운로드하면 문제없이 코드를 돌릴 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>torch torchvision opencv-python
python3 run_ssd_live_demo.py mb2-ssd-lite models/mb2-ssd-lite-Epoch-?-Loss-?.pth models/open-images-model-labels.txt
</code></pre></div></div>

<p>카메라가 실행되면 실제 강아지나 사진을 비춰서 모델이 코를 제대로 인식하나 살펴보자.</p>

<p>여기까지 잘 따라왔다면 이젠 PC에서 딥러닝을 돌릴 줄 아는 것이다. 축하한다.</p>

<h2 id="️-모델-변환">🛤️ 모델 변환</h2>

<p>우리가 앞에서 얻은 모델을 앱에 내장하기 위해서는 <code class="language-plaintext highlighter-rouge">.pth</code>로 되어있는 파일 형식을 <code class="language-plaintext highlighter-rouge">.ptl</code>로 바꿔주어야 한다.</p>

<p><a href="https://playtorch.dev/docs/tutorials/prepare-custom-model/">PlayTorch</a> 공식문서에 나와있는 코드를 조금 수정하여 모델 변환 코드를 작성하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">from</span> <span class="n">torch.utils.mobile_optimizer</span> <span class="kn">import</span> <span class="n">optimize_for_mobile</span>
<span class="kn">from</span> <span class="n">vision.ssd.mobilenet_v2_ssd_lite</span> <span class="kn">import</span> <span class="n">create_mobilenetv2_ssd_lite</span><span class="p">,</span> <span class="n">create_mobilenetv2_ssd_lite_predictor</span>

<span class="n">model</span> <span class="o">=</span> <span class="nf">create_mobilenetv2_ssd_lite</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">is_test</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">model_path</span> <span class="o">=</span> <span class="sh">'</span><span class="s">models/mb2-ssd-lite-Epoch-?-Loss-?.pth</span><span class="sh">'</span>
<span class="n">model</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

<span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>

<span class="n">scripted_model</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">jit</span><span class="p">.</span><span class="nf">script</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">optimized_model</span> <span class="o">=</span> <span class="nf">optimize_for_mobile</span><span class="p">(</span><span class="n">scripted_model</span><span class="p">)</span>
<span class="n">optimized_model</span><span class="p">.</span><span class="nf">_save_for_lite_interpreter</span><span class="p">(</span><span class="sh">"</span><span class="s">models/mb2-ssd-lite-Epoch-?-Loss-?.ptl</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">model successfully exported</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.ptl</code> 파일을 얻기 위해서는 먼저 <code class="language-plaintext highlighter-rouge">torch.jit</code>을 사용하여 모델을 <code class="language-plaintext highlighter-rouge">Eager mode</code>에서 <code class="language-plaintext highlighter-rouge">Script mode</code>로 변환해주어야 한다. 변환 방법에는 <strong>torch.jit.trace</strong>와 <strong>torch.jit.script</strong> 이렇게 두 가지 방식이 있는데 여기서는 <code class="language-plaintext highlighter-rouge">script</code>를 사용하였다.</p>

<p><code class="language-plaintext highlighter-rouge">trace</code> 방식은 모델 변환시 성공률은 높지만 제대로된 변환을 보장해주지는 않는다. 반면 <code class="language-plaintext highlighter-rouge">script</code> 방식은 모델 구조에 꽤나 엄격하기에 제대로 된 형태가 아닐 경우 에러를 내뿜을 가능성이 높다. 가능하다면 둘 다 시도하여 모델 성능을 비교해보자.</p>

<p>아래는 <code class="language-plaintext highlighter-rouge">script</code>방식에서 자주 마주치는 에러이다. 동적 인덱싱을 사용할 수 없기 때문에 <code class="language-plaintext highlighter-rouge">enumerate</code> 함수로 iterator를 사용하여 해결하거나 integer를 직접 넣어 인덱싱 하는 수밖에 없다.</p>

<blockquote>
  <p>⚠️ ModuleList/Sequential indexing is only supported with integer literals.</p>
</blockquote>

<p>변환을 위해 <code class="language-plaintext highlighter-rouge">/vision/ssd/ssd.py</code>의 <code class="language-plaintext highlighter-rouge">forward</code> 함수를 수정해주었다. 가독성을 조금 해치지만 enumerate를 사용하기 애매한 부분은 for 문을 풀어서 작성하였다.</p>

<h2 id="-모델-적용">🍿 모델 적용</h2>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Pytorch, React Native, labelImg" /><summary type="html"><![CDATA[[현재 작성중인 글입니다.]]]></summary></entry><entry><title type="html">[FastAPI] API 요청 시 307 Temporary Redirect가 뜨는 이슈</title><link href="http://localhost:4000/fastapi-redirect/" rel="alternate" type="text/html" title="[FastAPI] API 요청 시 307 Temporary Redirect가 뜨는 이슈" /><published>2024-06-15T00:00:00+07:00</published><updated>2024-06-15T00:00:00+07:00</updated><id>http://localhost:4000/fastapi-redirect</id><content type="html" xml:base="http://localhost:4000/fastapi-redirect/"><![CDATA[<p>어느 순간부터 FastAPI 서버에 API 요청을 할 때 status code가 307가 뜨기 시작했다.</p>

<p>분명 쿠버네티스에 띄워놓은 서비스는 잘 돌아가고 있는데 로컬에서만 안되는게 신기했다.</p>

<p>저번에 건드린 <code class="language-plaintext highlighter-rouge">next.config.mjs</code> 파일이 문제가 되었나해서 <code class="language-plaintext highlighter-rouge">rewrite()</code> 함수를 요리조리 건드려 보았지만 여전히 응답은 같았다.</p>

<p>그러던 중 스택오버플로에서 해답을 찾았다. (<a href="https://stackoverflow.com/questions/70351360/keep-getting-307-temporary-redirect-before-returning-status-200-hosted-on-fast">stackoverflow</a>)</p>

<p>FastAPI로 서버를 구성하다보면 보통 API url 끝에 <code class="language-plaintext highlighter-rouge">/</code> 를 붙이는 경우가 많다.</p>

<p>예를 들면 이런 경우다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@app</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"/patients/"</span><span class="o">)</span>
</code></pre></div></div>

<p>보통은 API 요청을 할 때 끝부분에 <code class="language-plaintext highlighter-rouge">/</code>가 있든 없든 문제가 발생하지 않지만 로컬에서는 <code class="language-plaintext highlighter-rouge">/</code>를 빠트리게 되면 <code class="language-plaintext highlighter-rouge">307 Temporary Redirect</code> 이슈가 발생하는 듯하다.</p>

<p>FastAPI는 docs를 제공하므로 백엔드 개발자가 실수할 일이 없으니 프론트 개발자가 API url을 작성할 때 주의하면 되겠다.</p>

<p>결론은 <strong><code class="language-plaintext highlighter-rouge">/</code> 확인을 잘하자</strong>.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Python, FastAPI" /><summary type="html"><![CDATA[어느 순간부터 FastAPI 서버에 API 요청을 할 때 status code가 307가 뜨기 시작했다.]]></summary></entry><entry><title type="html">[Next] 서비스 배포 시 Mixed Content 오류</title><link href="http://localhost:4000/mixed-content/" rel="alternate" type="text/html" title="[Next] 서비스 배포 시 Mixed Content 오류" /><published>2024-06-02T00:00:00+07:00</published><updated>2024-06-02T00:00:00+07:00</updated><id>http://localhost:4000/mixed-content</id><content type="html" xml:base="http://localhost:4000/mixed-content/"><![CDATA[<p>Next.js(@14.2.3)를 활용하여 만든 EMR 데모 버전을 도커로 말아 쿠버네티스에 올렸는데 자꾸 <code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러가 나고 있었다.</p>

<p><code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러는 웹페이지는 <code class="language-plaintext highlighter-rouge">https</code>로 서비스되고 있는데 어떠한 리소스를 <code class="language-plaintext highlighter-rouge">http</code>로 로드하려고 할 때 발생한다.</p>

<p>API URL은 <code class="language-plaintext highlighter-rouge">.env.*</code>에서 관리를 하고 있기 때문에 모든 API 콜에 있어서 동일하게 적용될 터이고 적용한 프로토콜은 분명 <code class="language-plaintext highlighter-rouge">https</code>였다.</p>

<p>구글링 해보면 흔히 나오는 해결 방법은 두 가지이다.</p>

<h3 id="1-헤더-안에-보안-정책-관련-메타-태그를-추가하기">1. 헤더 안에 보안 정책 관련 메타 태그를 추가하기</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// layout.tsx</span>
<span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">Head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">meta</span>
      <span class="nx">httpEquiv</span><span class="o">=</span><span class="dl">"</span><span class="s2">Content-Security-Policy</span><span class="dl">"</span>
      <span class="nx">content</span><span class="o">=</span><span class="dl">"</span><span class="s2">upgrade-insecure-requests</span><span class="dl">"</span>
    <span class="o">/&gt;</span> <span class="c1">// &lt;- add this</span>
  <span class="o">&lt;</span><span class="sr">/Head</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span></code></pre></div></div>

<p>모든 리소스를 강제로 https로 바꿔서 로드하는 것이라 효과가 있을거라 생각했지만 에러가 해결되지는 않았다.</p>

<p><code class="language-plaintext highlighter-rouge">http</code>로 밖에 로드되지 않는 리소스도 분명 있을 것이기에 모든 문제를 해결해주는 만능키는 아니다.</p>

<h3 id="2-next의-프록시-설정-변경">2. Next의 프록시 설정 변경</h3>

<p>처음에는 API URL로 들어갈 때 서버의 <code class="language-plaintext highlighter-rouge">Nginx</code> 안쪽에서 발생하는 리디렉션이 문제일까 하고 여러 설정을 바꿔보았지만 아무런 문제가 없었다.</p>

<p>그렇다면 매우 높은 확률로 클라이언트쪽 문제일 가능성이 높다.</p>

<p>우선, Next는 특정 경로에 대해 프록시를 설정할 수 있는 기능을 제공한다.</p>

<p>이 기능을 사용하는 이유는 여러가지 있을테지만 필자의 경우에는 보통 서버 코드를 변경할 수 없는 경우 <code class="language-plaintext highlighter-rouge">CORS</code> 문제를 해결하기 위해 사용한다.</p>

<p>관련 설정은 <code class="language-plaintext highlighter-rouge">next.config.mjs</code> 파일 안에서 설정해주면 되고, 이번 프로젝트에서는 로컬 컴퓨터에서 PACS 서버에 접근할 때 활용하고 있었다.</p>

<p>코드는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nf">rewrites</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/pacs-api/:path*</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">destination</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://localhost:8042/:path*</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">];</span>
  <span class="p">},</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/pacs-api</code>로 시작하는 URL은 dev 환경에서만 사용하고 있었기에 전혀 의심하지 않고 있었는데 <code class="language-plaintext highlighter-rouge">Mixed Content</code> 에러를 판단함에 있어서 아무래도 source URL과는 상관없이 프로토콜을 우선적으로 적용하는 듯하다.</p>

<p>즉, destination이 <code class="language-plaintext highlighter-rouge">http</code>이기에 해당 웹페이지에서 보내는 모든 리소스 요청은 source와 상관없이 <code class="language-plaintext highlighter-rouge">http</code>로 보내지고 있었다.</p>

<h1 id="결론">결론</h1>

<p>문제를 알았다면 해결은 어렵지 않다. <code class="language-plaintext highlighter-rouge">development</code> 환경에서만 해당 프록시가 동작하도록 바꿔주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nf">rewrites</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">development</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">source</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/pacs-api/:path*</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">destination</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://localhost:8042/:path*</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span> <span class="c1">// 다른 환경에서는 리디렉션을 적용하지 않음</span>
  <span class="p">}</span>
<span class="p">},</span>
</code></pre></div></div>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Next" /><summary type="html"><![CDATA[Next.js(@14.2.3)를 활용하여 만든 EMR 데모 버전을 도커로 말아 쿠버네티스에 올렸는데 자꾸 Mixed Content 에러가 나고 있었다.]]></summary></entry><entry><title type="html">[H/W] Mac에서 시리얼 통신하기</title><link href="http://localhost:4000/serial-port/" rel="alternate" type="text/html" title="[H/W] Mac에서 시리얼 통신하기" /><published>2024-04-21T00:00:00+07:00</published><updated>2024-04-21T00:00:00+07:00</updated><id>http://localhost:4000/serial-port</id><content type="html" xml:base="http://localhost:4000/serial-port/"><![CDATA[<p><img src="/assets/img/serial-com.webp" alt="image" /></p>

<p>의료 장비를 맥북과 연결해서 시리얼 통신으로 데이터를 주고 받을 일이 있었다.</p>

<p>요즘은 평소에 시리얼 포트를 보는 것도 드문 일이거니와 과연 M1 칩 이후로는 연동이 잘 되는지도 알 수 없었다.</p>

<p>일단 <code class="language-plaintext highlighter-rouge">RS232-RS232</code> 케이블로 의료 기기에 하나를 꽂아주고 반대편 포트는 맥북의 허브 포트에 꽂을 수 있게 <code class="language-plaintext highlighter-rouge">Serial to USB</code> 어댑터를 연결해준다.</p>

<p>그대로 맥북에 연결하면 다음과 같이 <code class="language-plaintext highlighter-rouge">설정 &gt; 일반 &gt; 시스템 리포트</code> 상에 USB-Serial Controller가 나타난다. 즉, 하드웨어 상으로는 자동으로 연결을 인식해준다.</p>

<p><img src="/assets/img/serial-port-setting.png" alt="image" /></p>

<p>하지만 코드 상에서 시리얼 통신을 하기 위해서는 <code class="language-plaintext highlighter-rouge">/dev</code> 폴더 아래에 나타나는 장치 코드를 알아내야한다. 보통 <code class="language-plaintext highlighter-rouge">tty~</code>로 시작한다.</p>

<p>터미널에서 검색해보면 아직은 아무것도 나타나지 않는다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /dev/tty<span class="k">*</span>
<span class="c"># /dev/tty.Bluetooth-Incoming-Port</span>
</code></pre></div></div>

<p>아무래도 드라이버가 필요한 듯해서 찾아보았다.</p>

<p>일단 시스템 리포트에 찍히는 <code class="language-plaintext highlighter-rouge">Prolific Technology</code>에서 만든 시리얼 포트를 인식하기 위해서는 드라이버를 다운로드해야 한다.</p>

<p>중국에서 만들었는지 중국어로 된 사이트로 연결이 된다. 관련 macOS(구OSX) 전용 드라이버는 <a href="https://www.prolific.com.tw/US/ShowProduct.aspx?pcid=41&amp;showlevel=0041-0041">Prolific PL2303</a>이다.</p>

<p>하지만 설치를 완료해도 여전히 <code class="language-plaintext highlighter-rouge">/dev</code>에는 아무것도 나타나지 않는다?!</p>

<p>좀 더 검색을 해보니 <code class="language-plaintext highlighter-rouge">Serial to USB</code> 어댑터에도 드라이버가 필요한 듯하다…</p>

<p>이번에는 <code class="language-plaintext highlighter-rouge">FTDI</code>라는 홈페이지에 가서 <code class="language-plaintext highlighter-rouge">Virtual COM port(VCP)</code> 드라이버를 다운받는다.</p>

<blockquote>
  <p><strong>FTDI(Future Technology Devices International)</strong><br />
USB를 시리얼 포트로 변환하는 장치를 생산하는 회사. FTDI의 USB-시리얼 변환기는 컴퓨터의 USB 포트에 연결되어 있고, 시리얼 통신을 지원하는 장치와 통신할 수 있도록 시리얼 데이터를 USB 데이터로 변환한다. 이는 특히 시리얼 포트가 없는 현대의 컴퓨터나 장치와 통신하기 위해 사용된다.</p>
</blockquote>

<p>해당 드라이버는 컴퓨터가 USB 포트로 시리얼 통신을 할 수 있도록 도와주는 역할을 한다.</p>

<p>ARM 전용 dmg 파일을 다운받아서 설치한다. <strong>단, 주의해야할 점은 /Applications 폴더 아래에 놓고 실행을 해야 설치가 된다는 것이다. 이후 <code class="language-plaintext highlighter-rouge">설정 &gt; 개인정보 보호 및 보안</code>에서 관련 권한을 허용해 주어야 한다.</strong></p>

<p>관련 이슈를 <a href="https://www.reddit.com/r/MacOS/comments/17bnhvr/m2_mac_on_macos_sonoma_issues_with_prolific/?utm_source=embedv2&amp;utm_medium=post_embed&amp;utm_content=post_body&amp;embed_host_url=https://embed.notion.co/api/iframe">Reddit</a>에서도 잘 설명해주고 있다.</p>

<p>이제 <code class="language-plaintext highlighter-rouge">/dev</code> 폴더를 살펴보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /dev/tty<span class="k">*</span>
<span class="c"># /dev/tty.Bluetooth-Incoming-Port</span>
<span class="c"># /dev/tty.PL2303G-USBtoUART2130</span>
</code></pre></div></div>

<p>짜잔! 연결된 포트가 나타난다. 이제 관련 라이브러리(예 <a href="https://serialport.io">Node.js</a>)를 이용해서 시리얼 통신을 진행하면 된다.</p>

<p>맥에서 시리얼 통신을 할 때는 드라이버가 필수라는 사실만 알아두자.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Serial Port" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[터미널] Warp + Powerlevel10k + lsd</title><link href="http://localhost:4000/warp/" rel="alternate" type="text/html" title="[터미널] Warp + Powerlevel10k + lsd" /><published>2024-04-10T00:00:00+07:00</published><updated>2024-04-10T00:00:00+07:00</updated><id>http://localhost:4000/warp</id><content type="html" xml:base="http://localhost:4000/warp/"><![CDATA[<h1 id="소개">소개</h1>

<p>기존에는 개발 터미널로 <code class="language-plaintext highlighter-rouge">Iterm2</code>를 쓰고 있었는데 최근에 새로운 터미널을 알게되어 소개하고자 한다.</p>

<p><a href="https://www.warp.dev/a">Warp</a>라는 터미널인데 예전부터 눈여겨보고 있었던 녀석이기는 하다. 슬슬 이쪽으로 트렌드가 넘어오는 느낌도 든다.</p>

<p>추천하는 이유는 다음과 같다.</p>

<ol>
  <li>명령어 자동 완성 기능이 달려있다.</li>
  <li>AI 기능이 내장되어 있다.</li>
  <li>자주 쓰는 워크플로우를 <code class="language-plaintext highlighter-rouge">Warp Drive</code>에 저장해 놓을 수 있다.</li>
  <li>실행 블록별로 찾기, 복사 등 작업이 가능하다.</li>
</ol>

<p>속도는 Terminal.app 보다는 느리지만 Iterm보다는 확실히 빠르다. <a href="https://docs.warp.dev/how-does-warp-compare/performance">벤치마크</a>를 확인해보자.</p>

<p>이는 Warp에서 제공하는 벤치마크이므로 100% 신뢰할 수는 없지만 직접 사용해보니 체감상으로도 빠른 것 같다. 이외에도 편리한 기능이 많다.</p>

<p>다만, 아직 범용적으로 사용되기 어려운 단점도 있다.</p>

<ol>
  <li>zsh를 기본 쉘로 사용하는데 맨 처음 탭을 열 때 zsh 로딩이 조금 느리다.</li>
  <li>아직 한국어 지원이 완벽하지 않다. (한국어 파일명이 자음으로만 나온다)</li>
</ol>

<p>이와 같은 이유로 개발자 이외에는 쓰기 어려울 것 같다. 애초에 개발자가 아니면 터미널에 관심을 가지지 않겠지만…</p>

<p>위에 서술한 내용과는 별개로 사실 Warp로 넘어오게 된 이유는 간단하다.</p>

<p>🚀 <strong><code class="language-plaintext highlighter-rouge">터미널이 매우 깔끔하고 멋지다</code></strong></p>

<p><img src="/assets/img/warp.png" alt="image" /></p>

<hr />

<h1 id="설치">설치</h1>

<h3 id="-warp">● Warp</h3>

<p>우선 <a href="https://www.warp.dev/a">Warp 사이트</a>로 이동하여 다운받는다. 혹은 <code class="language-plaintext highlighter-rouge">brew install</code>도 가능하다.</p>

<p>설치 후 실행하면 바로 사용할 수 있다. 기존 테마도 멋있지만 커스텀 테마를 적용하는 것도 가능하다.</p>

<p>커스텀 테마는 <a href="https://terminal-themes.com/">관련 사이트</a>에서 다운받거나 yaml 파일을 직접 작성하여 적용할 수 있다.</p>

<p>필자는 <code class="language-plaintext highlighter-rouge">Seashell.yaml</code>을 다운 받아서 적용하였다. 테마 관련 폴더를 생성해서 그 안에 다운로드 받은 yaml 파일을 옮겨주면 된다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.warp/themes/
<span class="nb">cp</span> ~/Downloads/.yaml ~/.warp/themes/
</code></pre></div></div>

<p>이제 Warp 테마 설정에서 해당 테마 선택이 가능하다.</p>

<p><a href="https://docs.warp.dev/appearance/custom-themes">공식문서</a>에서도 커스텀 테마 적용 방법에 대해 상세히 설명하고 있으므로 한번 살펴보자.</p>

<h3 id="-powerlevel10k">● Powerlevel10k</h3>

<p>Iterm2를 사용할 때 zsh 프롬프트를 꾸며주기 위해 <code class="language-plaintext highlighter-rouge">powerlevel10k</code>를 적용했었는데 Warp도 zsh를 사용하므로 동일하게 적용이 가능하다.</p>

<p>기존에 Iterm2를 사용하시던 분이라면 자동으로 적용이 될 것이다.</p>

<p>Warp에서도 친절하게 <a href="https://www.warp.dev/blog/how-to-set-up-powerlevel10k-on-warp#setup">powerlevel10k를 적용하는 방법</a>에 대해서 설명해주고 있다.</p>

<p>p10k를 설치하기에 앞서 터미널 상에서 아이콘들이 제대로 나타나기 위해서 폰트를 적용해주어야 한다.</p>

<p>절차는 다음과 같다.</p>

<ol>
  <li><a href="https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#manual">Powerlevel10k 공식 깃허브 페이지</a>에서 MesloLGS NF 폰트를 다운로드한다. Regular, Bold, Italic, Bold Italic.ttf 파일을 모두 다운받아서 설치해준다.</li>
  <li>Warp의 설정에서 <code class="language-plaintext highlighter-rouge">Appearance &gt; Text</code> 로 이동한 뒤 <code class="language-plaintext highlighter-rouge">View all available system fonts</code> 박스를 체크해주고 드롭다운 메뉴에서 <code class="language-plaintext highlighter-rouge">MesloLGS NF</code> 폰트를 선택한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Appearance &gt; Prompt</code> 에서 <code class="language-plaintext highlighter-rouge">Sheell prompt (PS1)</code>을 골라준다.</li>
</ol>

<p>이제 p10k를 설치해보자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--depth</span><span class="o">=</span>1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k
<span class="nb">echo</span> <span class="s1">'source ~/powerlevel10k/powerlevel10k.zsh-theme'</span> <span class="o">&gt;&gt;</span>~/.zshrc 
</code></pre></div></div>

<p>설치가 완료되었다면 <code class="language-plaintext highlighter-rouge">exec zsh</code> 명령어로 테마 설정 마법사를 시작한다. 만일 설정창이 뜨지 않는다면 <code class="language-plaintext highlighter-rouge">p10k configure</code> 명령어를 활용한다.</p>

<p>이제 설정 마법사가 안내해 주는대로 개인의 취향에 맞게 설정해주면 된다.</p>

<h3 id="-lsd">● lsd</h3>

<p>아이콘 얘기가 나왔으니 <code class="language-plaintext highlighter-rouge">ls</code> 명령어를 입력했을 때 나오는 결과값에도 아이콘을 입혀보자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설치</span>
<span class="nv">$ </span>brew <span class="nb">install </span>lsd

<span class="c"># alias 설정</span>
<span class="nv">$ </span>vi ~/.zshrc

<span class="nb">alias ls</span><span class="o">=</span><span class="s1">'lsd'</span>
<span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -alhF'</span>
<span class="nb">alias </span><span class="nv">lt</span><span class="o">=</span><span class="s1">'ls --tree'</span>

<span class="nv">$ </span><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>

<p>이제 ls 명령을 입력하면 파일과 디렉토리의 차이가 한눈에 들어온다. 각 파일의 형태에 따라 아이콘이 다르게 표시되는 것도 볼 수 있다.</p>

<p><img src="/assets/img/lsd.png" alt="image" /></p>

<h3 id="-탭-이름-설정하기">● 탭 이름 설정하기</h3>

<p>Warp에서 탭을 열었을 때는 현재 경로가 탭 이름으로 표시되게 된다. 경로가 길 때는 잘 보이지 않으니 그냥 랜덤한 이모티콘으로 바꿔주자.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim ~/.zshrc
</code></pre></div></div>

<p>참고하고 싶은 분을 위해 .zshrc의 내용을 그대로 가져왔다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.</span>
<span class="c"># Initialization code that may require console input (password prompts, [y/n]</span>
<span class="c"># confirmations, etc.) must go above this block; everything else may go below.</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nt">-r</span> <span class="s2">"</span><span class="k">${</span><span class="nv">XDG_CACHE_HOME</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.cache</span><span class="k">}</span><span class="s2">/p10k-instant-prompt-</span><span class="k">${</span><span class="p">(%)</span><span class="k">:-</span><span class="p">%n</span><span class="k">}</span><span class="s2">.zsh"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">source</span> <span class="s2">"</span><span class="k">${</span><span class="nv">XDG_CACHE_HOME</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.cache</span><span class="k">}</span><span class="s2">/p10k-instant-prompt-</span><span class="k">${</span><span class="p">(%)</span><span class="k">:-</span><span class="p">%n</span><span class="k">}</span><span class="s2">.zsh"</span>
<span class="k">fi</span>

<span class="c"># ================================================= 이 부분 추가</span>
<span class="c"># set tab name randomly when a new tab is open</span>
<span class="k">function </span>set_name <span class="o">()</span> <span class="o">{</span>
  <span class="nv">emojis</span><span class="o">=(</span><span class="s2">"⚡️"</span> <span class="s2">"🔥"</span> <span class="s2">"👑"</span> <span class="s2">"🍻"</span> <span class="s2">"🚀"</span> <span class="s2">"💡"</span> <span class="s2">"🎉"</span> <span class="s2">"🌙"</span><span class="o">)</span>
  <span class="nv">RAND_EMOJI_N</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$RANDOM</span> <span class="o">%</span> <span class="k">${#</span><span class="nv">emojis</span><span class="p">[@]</span><span class="k">}</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
  <span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33]0;</span><span class="k">${</span><span class="nv">emojis</span><span class="p">[RAND_EMOJI_N]</span><span class="k">}</span><span class="se">\0</span><span class="s2">07"</span>
<span class="o">}</span>
<span class="c"># if the terminal is Zsh, then run set_name</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$ZSH_VERSION</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>precmd_functions+<span class="o">=(</span>set_name<span class="o">)</span>
<span class="k">fi</span>
<span class="c"># =================================================</span>

<span class="c"># set aliases for lsd package</span>
<span class="nb">alias ls</span><span class="o">=</span><span class="s1">'lsd'</span>
<span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -alhF'</span>
<span class="nb">alias </span><span class="nv">lt</span><span class="o">=</span><span class="s1">'ls --tree'</span>

<span class="nb">eval</span> <span class="si">$(</span>/opt/homebrew/bin/brew shellenv<span class="si">)</span>
<span class="nb">source</span> ~/powerlevel10k/powerlevel10k.zsh-theme

<span class="c"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span>
<span class="o">[[</span> <span class="o">!</span> <span class="nt">-f</span> ~/.p10k.zsh <span class="o">]]</span> <span class="o">||</span> <span class="nb">source</span> ~/.p10k.zsh
</code></pre></div></div>

<p>이제 적용해주면 된다.</p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.zshrc
</code></pre></div></div>

<h3 id="-vim-커스텀-테마">● Vim 커스텀 테마</h3>

<p>이제 웬만한 부분은 완성되었다.</p>

<p>Mac을 사용하다보면 <code class="language-plaintext highlighter-rouge">Vim</code>을 텍스트 편집기로 사용하게 되는데 좀 더 완벽을 기한다면 Vim 커스텀 테마까지 적용해보자. 문서 읽기가 매우 편해진다.</p>

<p>Warp 커스텀 테마 때와 마찬가지로 <a href="https://vimcolorschemes.com/top/">사이트</a>에서 원하는 테마를 다운받는다.</p>

<p>테마 관련 폴더를 생성해서 다운로드받은 파일을 옮겨준다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/.vim/colors
<span class="nb">cp</span> ~/Downloads/.yaml ~/.vim/colors/
vim ~/.vimrc
</code></pre></div></div>

<p>아래와 같이 설정해준다. 비어있다면 복사-붙여넣기를 한다.</p>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">" Syntax Highlighting
if has("</span>syntax<span class="s2">")
    syntax on
endif

set ts=4
set autoindent

colo  // &lt;- colors 안에 들어있는 .vim 파일명

set laststatus=2
set statusline=</span><span class="se">\ </span><span class="s2">%&lt;%l:%v</span><span class="se">\ </span><span class="s2">[%P]%=%a</span><span class="se">\ </span><span class="s2">%h%m%r</span><span class="se">\ </span><span class="s2">%F</span><span class="se">\</span><span class="s2">
</span></code></pre></div></div>

<p>vim을 재실행하면 테마가 적용된다.</p>

<p><img src="/assets/img/vim.png" alt="image" /></p>

<h2 id="결론">결론</h2>

<p>이제 VScode만 깔아준다면 개발 준비는 끝난 것이다.</p>

<p>다른거는 몰라도 <code class="language-plaintext highlighter-rouge">Warp + Powerlevel10k</code> 조합은 꼭 적용해보자. 할 일이 없어도 터미널을 켜고 있는 자신을 발견할 것이다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Mac, Terminal" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">[쿠버네티스] error: The connection to the server 192.168.x.x:6443 was refused - did you specify the right host or port?</title><link href="http://localhost:4000/k8s-install-error/" rel="alternate" type="text/html" title="[쿠버네티스] error: The connection to the server 192.168.x.x:6443 was refused - did you specify the right host or port?" /><published>2024-03-05T00:00:00+07:00</published><updated>2024-03-05T00:00:00+07:00</updated><id>http://localhost:4000/k8s-install-error</id><content type="html" xml:base="http://localhost:4000/k8s-install-error/"><![CDATA[<p>IDC에 서버를 구축하면서 오랜만에 순정 서버에 쿠버네티스를 설치할 일이 생겼다. 우분투는 이전에도 수없이 지우고 깔고 해봤기에 수월하게 넘어갔지만 오랜만에 하는 쿠버네티스 클러스터 구축에서 에러를 만나버렸다.</p>

<p><code class="language-plaintext highlighter-rouge">kubeadm init</code> 이후에 <code class="language-plaintext highlighter-rouge">kubectl get node</code>를 했을 때 처음에는 결과가 잘 나타나다가 시간이 조금 지나면 아래와 같은 에러가 나타나기 시작한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">error</span><span class="p">:</span> <span class="nx">The</span> <span class="nx">connection</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">server</span> <span class="mf">192.168</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">x</span><span class="p">:</span><span class="mi">6443</span> <span class="nx">was</span> <span class="nx">refused</span> <span class="o">-</span> <span class="nx">did</span> <span class="nx">you</span> <span class="nx">specify</span> <span class="nx">the</span> <span class="nx">right</span> <span class="nx">host</span> <span class="nx">or</span> <span class="nx">port</span><span class="p">?</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">6443</code>은 쿠버네티스에서 주로 사용하는 포트이고 192.168.x.x는 localhost니깐 위의 에러는 자기 자신에 연결할 수 없다는 이야기가 된다. 6443 포트를 통해서 자기 내부에서 돌고 있는 쿠버네티스 시스템과 통신을 하게 되는데 그게 불가능하다는 것은 쿠버네티스가 제대로 돌고 있지 않다는 것이다.</p>

<p>처음에는 UTM의 방화벽 정책 문제인가 싶었는데 조금 생각해보니 전혀 상관없는 문제였다.</p>

<p>컨테이너 런타임으로 containerd를 사용할 때는 <a href="https://kubernetes.io/ko/docs/setup/production-environment/container-runtimes/">공식문서</a>에서 말하길,</p>

<blockquote>
  <p>리눅스 배포판의 init 시스템이 systemd인 경우, systemd를 kubelet과 컨테이너 런타임의 cgroup 드라이버로 사용해야한다.</p>
</blockquote>

<p>라고 한다.</p>

<p>관련 설정 없이는 <code class="language-plaintext highlighter-rouge">systemd</code>와 <code class="language-plaintext highlighter-rouge">cgroupfs</code>가 cgroup driver로 혼용되기 때문에 이는 쿠버네티스 시스템에 큰 혼란을 초래하게 된다.</p>

<p>실제로도 watch 명령어를 통해서 kubeadm init 뒤에 초기 시스템 파드들이 어떻게 실행되는지 보았더니 계속 죽었다 살아나기를 반복하고 있었다.</p>

<p>해결 방법은 간단하다. 공식 문서에도 잘 나와있지만 아래를 참고해도 좋다. 컨테이너 런타임의 cgroup 드라이버를 설정해준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">containerd</span> <span class="nx">config</span> <span class="k">default</span> <span class="o">|</span> <span class="nx">sudo</span> <span class="nx">tee</span> <span class="o">/</span><span class="nx">etc</span><span class="o">/</span><span class="nx">containerd</span><span class="o">/</span><span class="nx">config</span><span class="p">.</span><span class="nx">toml</span>
<span class="nx">sudo</span> <span class="nx">sed</span> <span class="o">-</span><span class="nx">i</span> <span class="dl">'</span><span class="s1">s/SystemdCgroup = false/SystemdCgroup = true/g</span><span class="dl">'</span> <span class="o">/</span><span class="nx">etc</span><span class="o">/</span><span class="nx">containerd</span><span class="o">/</span><span class="nx">config</span><span class="p">.</span><span class="nx">toml</span>
<span class="nx">sudo</span> <span class="nx">service</span> <span class="nx">containerd</span> <span class="nx">restart</span>
</code></pre></div></div>

<p>공식 문서를 꼼꼼하게 읽자.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="Kubernetes, systemd" /><summary type="html"><![CDATA[IDC에 서버를 구축하면서 오랜만에 순정 서버에 쿠버네티스를 설치할 일이 생겼다. 우분투는 이전에도 수없이 지우고 깔고 해봤기에 수월하게 넘어갔지만 오랜만에 하는 쿠버네티스 클러스터 구축에서 에러를 만나버렸다.]]></summary></entry><entry><title type="html">[React Native] 화면 전체를 덮는 absolute 포지션의 컴포넌트 스타일링</title><link href="http://localhost:4000/absolute-panel/" rel="alternate" type="text/html" title="[React Native] 화면 전체를 덮는 absolute 포지션의 컴포넌트 스타일링" /><published>2024-02-22T00:00:00+07:00</published><updated>2024-02-22T00:00:00+07:00</updated><id>http://localhost:4000/absolute-panel</id><content type="html" xml:base="http://localhost:4000/absolute-panel/"><![CDATA[<p>화면 전체를 덮는 absolute 포지션의 컴포넌트를 구현할 때 보통 이런식으로 스타일링을 한다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">container</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">position</span><span class="p">:</span> <span class="dl">'</span><span class="s1">absolute</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">bottom</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">left</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nx">right</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<p>모달을 띄우거나 할 때 뒷 배경을 옅은 회색으로 한다던가 opacity를 주기 위해서 주로 쓰게 되는데 쓸 때마다 코드가 너무 길어져 신경이 쓰였다.</p>

<p>아무 생각 없이 쓰던거라 더 좋은 방법을 찾을 생각조차 안하고 있었는데 우연히 공식문서에서 관련 내용을 발견했다.</p>

<p>React Native에서는 다음과 같이 <strong>한 줄</strong>로 구현이 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">container</span><span class="p">:</span> <span class="p">{...</span><span class="nx">StyleSheet</span><span class="p">.</span><span class="nx">absoluteFillObject</span><span class="p">}</span>
</code></pre></div></div>
<p><a href="https://reactnative.dev/docs/stylesheet">공식문서 - StyleSheet</a></p>

<p>공식문서를 잘 읽어보는 것에 대한 중요성을 다시금 느낀다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="React Native" /><summary type="html"><![CDATA[화면 전체를 덮는 absolute 포지션의 컴포넌트를 구현할 때 보통 이런식으로 스타일링을 한다. container: { position: 'absolute', top: 0, bottom: 0, left: 0, right: 0 }]]></summary></entry><entry><title type="html">[React Native] 컴포넌트 속성을 통해 전달하는 문자열의 줄바꿈 방법</title><link href="http://localhost:4000/transmit-component/" rel="alternate" type="text/html" title="[React Native] 컴포넌트 속성을 통해 전달하는 문자열의 줄바꿈 방법" /><published>2024-02-21T00:00:00+07:00</published><updated>2024-02-21T00:00:00+07:00</updated><id>http://localhost:4000/transmit-component</id><content type="html" xml:base="http://localhost:4000/transmit-component/"><![CDATA[<p>특정 컴포넌트를 구현할 때 속성을 통해 문자열을 보내줄 때가 있다. 보통 config로 따로 저장해놓은 고정 문구를 넣어주는 경우에 많이 쓰인다.</p>

<p>이 경우에 디자인 상의 이유로 줄바꿈을 자주 사용하게 되는데, 따옴표 안에 개행문자<code class="language-plaintext highlighter-rouge">\n</code>를 넣어도 아무 일도 일어나지 않아 종종 당황하곤 한다. 이는 개행 문자가 그대로 문자열로 인식되기 때문이다.</p>

<p>줄바꿈이 제대로 이루어지게 하기 위해서는 <strong>중괄호</strong>를 사용해 주어야 한다. 이런식으로 말이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nc">OnBoardingPage</span>
  <span class="n">subtitle</span><span class="o">={</span>
    <span class="err">'</span><span class="n">집에서</span> <span class="n">얼마나</span> <span class="n">걷고</span><span class="o">,</span> <span class="n">뛰고</span><span class="o">,</span> <span class="n">쉬었는지</span> <span class="n">등의</span><span class="err">\</span><span class="n">n정보를</span> <span class="n">실시간으로</span> <span class="n">분석해드려요</span><span class="o">.</span><span class="err">'</span>
  <span class="o">}</span>
<span class="o">/&gt;</span>
</code></pre></div></div>

<blockquote>
  <p>chatGPT는 그 이유에 대해 이렇게 말한다.<br />
<strong>“중괄호를 사용하면 JavaScript 표현식을 평가하고 결과를 문자열로 변환하여 JSX에 삽입할 수 있습니다.”</strong></p>
</blockquote>

<p>비슷한 느낌으로 <code class="language-plaintext highlighter-rouge">React</code>나 <code class="language-plaintext highlighter-rouge">Next</code>에서는 아예 컴포넌트 형식으로 전달하는 것을 추천한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nc">CheckUpCard</span>
  <span class="n">content</span><span class="o">={</span>
    <span class="o">&lt;&gt;</span>
      <span class="n">질환</span> <span class="n">등의</span> <span class="n">감별을</span> <span class="n">위한</span>
      <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
      <span class="n">정밀검사</span>
    <span class="o">&lt;/&gt;</span>
  <span class="o">}</span>
<span class="o">/&gt;</span>
</code></pre></div></div>

<p>컴포넌트 형식으로 전달하는 방식은 <strong>반응형으로 페이지를 구현할 필요가 있을 때</strong> 사용하면 유용하다. 이 때 개행문자<code class="language-plaintext highlighter-rouge">\n</code> 대신 <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>태그를 사용하게 되는데 이렇게 되면 PC 버전이냐 모바일 버전이냐에 따라 줄바꿈을 다르게 적용할 수 있기 때문이다.</p>

<p>빈 태그가 아닌 &lt;div&gt;태그 등을 사용하면 스타일도 부여할 수 있으니 자유도가 한층 높아지는 것은 말할 것도 없다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="React Native, React, Next" /><summary type="html"><![CDATA[특정 컴포넌트를 구현할 때 속성을 통해 문자열을 보내줄 때가 있다. 보통 config로 따로 저장해놓은 고정 문구를 넣어주는 경우에 많이 쓰인다.]]></summary></entry><entry><title type="html">[React Native] onPress에서 화살표 표현식의 생략</title><link href="http://localhost:4000/arrow-in-onpress/" rel="alternate" type="text/html" title="[React Native] onPress에서 화살표 표현식의 생략" /><published>2024-02-20T00:00:00+07:00</published><updated>2024-02-20T00:00:00+07:00</updated><id>http://localhost:4000/arrow-in-onpress</id><content type="html" xml:base="http://localhost:4000/arrow-in-onpress/"><![CDATA[<p>React Native에서 onPress를 사용할 때 무의식적으로 화살표 표현식 <code class="language-plaintext highlighter-rouge">()=&gt;</code>을 사용하고 있었는데 어느날 특정 경우에 생략이 가능하다는
것을 알게 되었다.</p>

<p>코드를 한 글자라도 줄일 수 있다는 생각에 과연 어떠한 조건에서 가능한지 궁금해서 찾아보았다. 다음의 두 가지 경우를 살펴보자.</p>

<h3 id="1">1</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onPress</span><span class="o">={()=&gt;</span><span class="n">handlePressFirst</span><span class="o">(</span><span class="n">value</span><span class="o">)}</span>
</code></pre></div></div>

<h3 id="2">2</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onPress</span><span class="o">={</span><span class="n">handlePressSecond</span><span class="o">}</span>
</code></pre></div></div>

<p>둘 다 정상적으로 실행되는 예시이다. 차이를 알겠는가?</p>

<p><code class="language-plaintext highlighter-rouge">handlePressFirst</code> 함수는 value라는 인자를 받고 있고 <code class="language-plaintext highlighter-rouge">handlePressSecond</code>는 아무런 인자 없이 실행되는 함수임을 알 수 있다.</p>

<p>만약 이렇게 하면 어떻게 될까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onPress</span><span class="o">={</span><span class="n">handlePressFirst</span><span class="o">(</span><span class="n">value</span><span class="o">)}</span>
</code></pre></div></div>

<p>이렇게 되면 해당 페이지가 렌더링 될 때 클릭 이벤트가 없어도 handlePressFirst 함수가 자동으로 실행될 것이다. 이는 예상치 못한 버그를 발생시킬 수 있으므로 좋지 않다. 주의하자.</p>

<p>다만 전달할 인자가 아무것도 없는데 화살표 표현식을 사용하는 것은 아무런 문제가 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onPress</span><span class="o">={()=&gt;</span><span class="n">handlePressSecond</span><span class="o">()}</span>
</code></pre></div></div>

<p>가독성을 올리고 싶다면 onPress 안에 들어가는 함수가 아무런 인자를 받지 않는 함수일 때 화살표 표현식과 함수 뒤의 빈 괄호를 생략하면 된다.</p>

<p>잘 써먹을 만한 팁이지만 괜히 헷갈린다면 무조건 onPress 안에 <code class="language-plaintext highlighter-rouge">()=&gt;</code>를 넣자.</p>

<p>참고로 이는 React의 onClick에서도 동일하다.</p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="React Native" /><summary type="html"><![CDATA[React Native에서 onPress를 사용할 때 무의식적으로 화살표 표현식 ()=&gt;을 사용하고 있었는데 어느날 특정 경우에 생략이 가능하다는 것을 알게 되었다.]]></summary></entry><entry><title type="html">[React/RN] map 함수 안에서의 return문 사용법</title><link href="http://localhost:4000/return-in-map/" rel="alternate" type="text/html" title="[React/RN] map 함수 안에서의 return문 사용법" /><published>2024-02-05T00:00:00+07:00</published><updated>2024-02-05T00:00:00+07:00</updated><id>http://localhost:4000/return-in-map</id><content type="html" xml:base="http://localhost:4000/return-in-map/"><![CDATA[<p>개발을 처음 배울 시절, 궁금했던 것들을 하나하나 메모하면서 나중에 블로그 글로 하나씩 적어야겠다고 생각했는데 벌써 어언 1년이 지나서 이제서야 글로 옮긴다.</p>

<p>JS 문법에도 익숙지 않아서 map 함수를 보면 지레 겁을 먹었던 적도 있었는데 이제는 이런 함수의 존재가 너무나도 고맙다.</p>

<p>항상 사용할 때마다 return문을 꼭 써야하는 것인지 궁금했었는데 오늘 그 이야기를 하고자한다.</p>

<p>답을 먼저 말하면 <strong><code class="language-plaintext highlighter-rouge">그렇지 않다</code></strong>이다.</p>

<p>map 함수 안에서 return 문의 유무를 결정하는 기준은 화살표(=&gt;) 뒤에 <strong>중괄호를 쓰냐 소괄호를 쓰냐에 따라</strong> 갈리게 되는데 일반적으로 소괄호를 쓰는 형태는 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="o">.</span><span class="na">map</span><span class="o">((</span><span class="n">value</span><span class="o">,</span> <span class="n">key</span><span class="o">)=&gt;(&lt;</span><span class="nc">View</span> <span class="n">key</span><span class="o">={</span><span class="n">key</span><span class="o">}&gt;[</span><span class="n">컴포넌트</span><span class="o">]&lt;/</span><span class="nc">View</span><span class="o">&gt;))</span>
</code></pre></div></div>

<p>더 나아가 소괄호가 생략되는 경우도 많고 이는 코드가 훨씬 깔끔해 보이는 장점을 가진다.</p>

<p>반대로 중괄호를 쓰게 되면 아래와 같이 꼭 return문을 넣어주어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="o">.</span><span class="na">map</span><span class="o">((</span><span class="n">value</span><span class="o">,</span> <span class="n">key</span><span class="o">)=&gt;{</span>
  <span class="kd">const</span> <span class="n">newValue</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// 새 변수 정의</span>
  <span class="k">return</span><span class="o">(</span>
    <span class="o">&lt;</span><span class="nc">View</span> <span class="n">key</span><span class="o">={</span><span class="n">key</span><span class="o">}&gt;</span>
      <span class="o">&lt;</span><span class="nc">Text</span><span class="o">&gt;</span>
        <span class="o">{</span><span class="n">newValue</span><span class="o">}</span>
      <span class="o">&lt;/</span><span class="nc">Text</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="nc">View</span><span class="o">&gt;</span>
  <span class="o">);</span>
<span class="o">})</span>
</code></pre></div></div>

<p>return을 쓰면 필연적으로 코드가 길어지게 되므로 항상 소괄호를 쓰는게 나아보일 수 있는데, 단 중괄호를 썼을 때 생기는 중요한 이점이 하나 존재한다.</p>

<p>바로 map 함수 내부에서 새로운 변수를 정의할 수 있다는 것이다. 이는 코드의 중복을 막아 가독성을 좋게 하는데 매우 중요할 수 있다.</p>

<p>하지만 그 뿐이므로 <strong>새로운 변수를 정의하는 경우를 제외한다면 return문은 과감히 생략해주자.</strong></p>]]></content><author><name>./workspace</name><email>sewoomkim93@gmail.com</email></author><category term="Blog" /><category term="React, React Native, Javascript" /><summary type="html"><![CDATA[개발을 처음 배울 시절, 궁금했던 것들을 하나하나 메모하면서 나중에 블로그 글로 하나씩 적어야겠다고 생각했는데 벌써 어언 1년이 지나서 이제서야 글로 옮긴다.]]></summary></entry></feed>